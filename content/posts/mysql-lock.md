---
title: "Mysql Lock"
date: 2020-11-09T14:43:10+08:00
draft: false
---

一方面要最大化程度利用数据库的并发访问，另一方面要确保每个用户能以一致性读取和修改数据。

为此就有了锁的机制，也是数据库系统区别于文件系统的关键特征

### local 与 latch

latch 是轻量级的锁，要求锁定的时间必须非常短。若持续的时间长，则性能会非常差

innodb 中， latch 分为 mutex (互斥量) 和 rwlock(读写锁)。 目的是用来保证并发线程操作临界资源的正确性，通常没有死锁检测机制

lock 的对象是事务，用来锁定数据库中的对象，如，表，页，行。并且尽在事务commit, rollback后释放。另外lock是由死锁机制


![lock and latch](/images/epub_603246_85.jpg)


### 锁的算法

行锁的3种算法

- Record lock： 单个行记录上的锁
- gap lock 间隙锁 锁定一个范围，但不包括记录本身
- next-key lock: gap lock + record lock 锁定一个范围，且锁定记录本身

锁的问题

锁定机制可以实现事务的隔离性要求，使得事务并发工作，锁提高了并发，却会带来其他的问题

- 脏读 
- 不可重复读
- 丢失更新

### 死锁

死锁是指两个或两个以上的事务在执行过程种，因夺锁资源而造成的一种互相等待的现象

解决死锁的最简单的方式是不要等待，将任何等待都转化为回滚，并且事务重新开始。(缺点： 导致并发性能下降，甚至任何事务都不能进行。而且很难被发现，并且浪费资源)

其次是超时，即当两个事务互相等待，当一个等待时间超过设置的某一个阙值时，其中一个事务进行回滚， 另一个等待事务继续进行。  innodb种 `innodb_lock_wait_timeout` 设置超时时间

当前数据库普遍采用 wait-for graph (等待图) 的方式进行死锁检测


避免死锁的方法: 银行家算法

解决死锁的方法

![解决死锁的方法](/images/20201109154256.png)
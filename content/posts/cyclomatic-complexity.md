---
title: "Cyclomatic Complexity"
date: 2020-12-09T00:20:13+08:00
draft: false
---

圈复杂度(Cyclomatic complexity)是一种代码复杂度的衡量标准，在1976年由Thomas J. McCabe, Sr. 提出。
在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。

### 定义

软件源码某部分的圈复杂度就是这部分代码中线性无关路径的数量。

### 举例
如果一段源码中不包含控制流语句（条件或决策点），那么这段代码的圈复杂度为1，因为这段代码中只会有一条路径；如果一段代码中仅包含一个if语句，且if语句仅有一个条件，那么这段代码的圈复杂度为2；包含两个嵌套的if语句，或是一个if语句有两个条件的代码块的圈复杂度为3。

### 计算

它的计算方法很简单：

计算公式1：V(G)=e-n+2p。其中，e表示控制流图中边的数量，n表示控制流图中节点的数量，p图的连接组件数目（图的组件数是相连节点的最大集合）。因为控制流图都是连通的，所以p为1.

计算公式2：V(G)=区域数=判定节点数+1。其实，圈复杂度的计算还有更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1，也即控制流图的区域数。
对于多分支的CASE结构或IF-ELSEIF-ELSE结构，统计判定节点的个数时需要特别注意一点，要求必须统计全部实际的判定节点数，也即每个ELSEIF语句，以及每个CASE语句，都应该算为一个判定节点。

计算公式3：V(G)=R。其中R代表平面被控制流图划分成的区域数。

针对程序的控制流图计算圈复杂度V(G)时，最好还是采用第一个公式，也即V(G)=e-n+2；而针对模块的控制流图时，可以直接统计判定节点数，这样更为简单；针对复杂的控制流图是，使用区域计算公式V(G)=R更为简单。

#### 节点判定法

其中 P 为判定节点数，常见的判定节点有：

if 语句
while 语句
for 语句
case 语句
catch 语句
and 和 or 布尔操作
? : 三元运算符
对于多分支的 case 结构或 if - else if - else 结构，统计判定节点的个数时需要特别注意：必须统计全部实际的判定节点数，也即每个 else if 语句，以及每个 case 语句，都应该算为一个判定节点。

```js
// 1(while) + 1(while) + 1(if) + 1 = 4
void sort(int *A)
{
  int i = 0;
  int n = 5;
  int j = 0;
  while (i < (n - 1)) 
  {
    j = i + 1;
    while (j < n) 
    {
      if (A[i] < A[j]) 
      {
        swap(A[i], A[j]);
      }
    }
    i = i + 1;
  }
}

// 1(for) + 2(if) + 1 = 4

int find (int match)
{
  for (int var in list) 
  {
    if (var == match && var != NAN) 
    {
      return var;
    }
  }
}
```

### 采用圈复杂度去衡量代码的好处

1. 指出极复杂模块或方法，这样的模块或方法也许可以进一步细化。


2. 限制程序逻辑过长

McCabe&Associates 公司建议尽可能使 V（G） <= 10。NIST（国家标准技术研究所）认为在一些特定情形下，模块圈复杂度上限放宽到 15 会比较合适。
 
因此圈复杂度 V（G）与代码质量的关系如下： 
V（G） ∈ [ 0 , 10 ]：代码质量不错； 
V（G） ∈ [ 11 , 15 ]：可能存在需要拆分的代码，应当尽可能想措施重构； 
V（G） ∈ [ 16 , ∞ )：必须进行重构；


3. 方便做测试计划，确定测试重点。
 
许多研究指出一模块及方法的圈复杂度和其中的缺陷个数有相关性，许多这类研究发现圈复杂度和模块或者方法的缺陷个数有正相关的关系：圈复杂度最高的模块及方法，其中的缺陷个数也最多，做测试时做重点测试。


### 可以降低圈复杂度的方法

- 简化、合并条件表达式
- 将条件判定提炼出独立函数
- 将大函数拆成小函数
- 以明确函数取代参数
- 替换算法
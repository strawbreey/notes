<!DOCTYPE html>
<html lang="en">
  <head>
	<meta name="generator" content="Hugo 0.67.0-DEV" />
    
      <title>
        Strawbreey Notes
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content=""
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="/" />





<link rel="stylesheet" href="/assets/style.css" />

<link rel="stylesheet" href="/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="/favicon.png" />





<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Strawbreey Notes"/>
<meta name="twitter:description" content=""/>



<meta property="og:title" content="Strawbreey Notes" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />
<meta property="og:updated_time" content="2020-09-14T16:46:08+08:00" /><meta property="og:site_name" content="Strawbreey Notes" />



<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Strawbreey Notes" />



  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    
    <span class="logo__text">
      Strawbreey Notes
    </span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/showcase">Showcase</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  
  
    
  
  

  

  <div class="posts">
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/network-agent/">Network Agent</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-20
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/network-agent/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/php-timeout/">Php Timeout</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-20
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            设置PHP脚本执行超时的时间有下面这样一些方法：
php.ini 中限定程序的最长执行时间是 30 秒，这是由 php.ini 配置文件中的 max_execution_time 变量指定，倘若你有一个需要颇多时间才能完成的程序代码，代码会由于超时而执行失败，例如要发送很多电子邮件给大量收件者，或者要进行繁重的数据分析工作，服务器会在 30 秒后强行中止正在执行的程序，如何解决这个问题呢。
在php.ini里面设置 max_execution_time = 1800; 脚本被解析器中止之前允许的最大执行时间
通过PHP的 ini_set 函数设置 ini_set(“max_execution_time”, “1800”);
通过set_time_limit 函数设置 set_time_limit(1800) ;
在php-fpm.conf中设置 request_terminate_timeout 请求开始n秒
注意
request_terminate_timeout 适用于，当max_execution_time由于某种原因无法终止脚本的时候，会把这个php-fpm请求干掉。
web请求php执行时间受到2方面控制，一个是php.ini的max_execution_time（要注意的是sleep，http请求等待响应的时间是不算的，这里算的是真正的执行时间），另一个是php-fpm request_terminate_timeout 设置，这个算的是请求开始n秒。
nginx的关键参数是 fastcgi 相关的 timeout，即：fastcgi_connect_timeout，fastcgi_read_timeout，fastcgi_send_timeout
这几个 nginx 参数的主语都是 nginx，所以 fastcgi_connect_timeout 的意思是 nginx 连接到 fastcgi 的超时时间，fastcgi_read_timeout 是 nginx 读取 fastcgi 的内容的超时时间，fastcgi_send_timeout 是 nginx 发送内容到 fastcgi 的超时时间。
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/php-timeout/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/vim-swap/">Vim Swap</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-20
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            Found a swap file by the name E325: ATTENTIONFound a swap file by the name &quot;.git/.MERGE_MSG.swp&quot;owned by: xxxxxx dated: Mon Nov 12 23:17:40 2012file name: ~xxxxxx/Desktop/My-ios-App/.git/MERGE_MSGmodified: YESuser name: xxxxxx host name: unknown-b8-8d-12-22-27-72.lanprocess ID: 1639While opening file &quot;.git/MERGE_MSG&quot;dated: Tue Nov 13 14:06:48 2012NEWER than swap file!(1) Another program may be editing the same file.If this is the case, be careful not to end up with twodifferent instances of the same file when making changes.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/vim-swap/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/php-exit-and-die/">Php Exit and Die</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-20
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/php-exit-and-die/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-string-methods/">Js String Methods</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-20
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-string-methods/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/recommended-books/">Recommended Books</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-20
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            javascript angular vue react nest.js mysql redis php golang linux nginx git   计算机程序设计艺术
C Primer Plus
C程序设计语言
鸟哥的Linux私房菜
TCP/IP详解卷1：协议
Java编程语言
Python核心编程
计算机导论   MIT 6.0001
Harvard的CS50
Berkeley的CS61A
每天一本编程书，每天进步一点点
19CS小硕校招面试心得、自学CS经验及找工作分享
MIT的课表
如何评价 Scott H.Young 一年内自学完 MIT 计算机专业的全部 33 门课程？
How Much Can You Change Yourself?
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/recommended-books/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/linux-shell/">Linux Shell</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-19
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/linux-shell/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/linux-bash/">Linux Bash</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-19
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/linux-bash/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/curl/">Curl</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-19
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            <p>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。
cURL是一个开源项目，主要的产品是curl（命令行工具）和libcurl（C语言的API库），两者功能均是：基于网络协议，对指定URL进行网络传输。[2][3]
cURL涉及是任何网络协议传输，不涉及对具体数据的具体处理。（如：html的渲染等）</p>
<h1 id="简单模式curl-httpexamplecom-详细verbose模式curl---verbose-httpexamplecomcurl--v-httpexamplecom-下载outputcurl---output-outputhtml-httpexamplecomcurl--o-outputhtml-httpexamplecom-重定向curl默认不会重定向curl---location-outputhtml-httpexamplecomcurl--l-outputhtml-httpexamplecomcurl-httphttpbinorguser-agentcurl-httpshttpbinorggetshow_env1curl-和-wget-区别-wget是个专职的下载利器简单专一极致而curl可以下载但是长项不在于下载而在于模拟提交web数据postget请求调试网页等等">简单模式curl <a href="http://example.com">http://example.com</a># 详细（verbose）模式：curl &ndash;verbose <a href="http://example.com">http://example.com</a>curl -v <a href="http://example.com">http://example.com</a># 下载（output）curl &ndash;output output.html <a href="http://example.com/">http://example.com/</a>curl -o output.html <a href="http://example.com/">http://example.com/</a># 重定向：（curl默认不会重定向）curl &ndash;location output.html <a href="http://example.com/">http://example.com/</a>curl -L output.html <a href="http://example.com/">http://example.com/</a>curl <a href="http://httpbin.org/user-agent">http://httpbin.org/user-agent</a>curl <a href="https://httpbin.org/get?show_env=1">https://httpbin.org/get?show_env=1</a>curl 和 wget 区别 wget是个专职的下载利器，简单，专一，极致；而curl可以下载，但是长项不在于下载，而在于模拟提交web数据，POST/GET请求，调试网页，等等。</h1>
<p>在下载上，也各有所长，wget可以递归，支持断点；而curl支持URL中加入变量，因此可以批量下载。
libcurl libcurl主要功能就是用不同的协议连接和沟通不同的服务器~也就是相当封装了的sockPHP 支持libcurl（允许你用不同的协议连接和沟通不同的服务器）。 libcurl当前支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传（当然你也可以使用PHP的ftp扩展）, HTTP基本表单上传，代理，cookies,和用户认证。
php cURL PHP 支持 Daniel Stenberg 创建的 libcurl 库，能够连接通讯各种服务器、使用各种协议。libcurl 目前支持的协议有 http、https、ftp、gopher、telnet、dict、file、ldap。 libcurl 同时支持 HTTPS 证书、HTTP POST、HTTP PUT、 FTP 上传(也能通过 PHP 的 FTP 扩展完成)、HTTP 基于表单的上传、代理、cookies、用户名+密码的认证。</p>

          
        
      </div>
      
        <div><a class="read-more button" href="/posts/curl/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-microtask-queue/">Js Microtask Queue</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-18
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。
理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。
事件循环 事件循环 的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。
引擎的一般算法：
当有任务时：  从最先进入的任务开始执行。   休眠直到出现任务，然后转到第 1 步。  两个细节：
引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。
如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，无法处理用户事件，因此，在一定时间后浏览器会在整个页面抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。
拆分CPU过载任务 例如，语法高亮（用来给本页面中的示例代码着色）是相当耗费 CPU 资源的任务。为了高亮显示代码，它执行分析，创建很多着了色的元素，然后将它们添加到文档中 —— 对于文本量大的文档来说，需要耗费很长时间。
当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间，这是不可接受的。
我们可以通过将大任务拆分成多个小任务来避免这个问题。高亮显示前 100 行，然后使用 setTimeout（延时参数为 0）来安排（schedule）后 100 行的高亮显示，依此类推
进度指示 宏任务和微任务 除了本章中所讲的 宏任务（macrotask） 外，还有在 微任务（Microtask） 一章中提到的 微任务（microtask）。
微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式。
每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。
setTimeout(() =&gt; alert(&quot;timeout&quot;));// 微任务Promise.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-microtask-queue/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/mysql-utf8/">Mysql Utf8</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-17
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/mysql-utf8/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-garbage-colloction/">Js Garbage Colloction</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-17
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-garbage-colloction/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-optional-chaining/">Js Optional Chaining</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-17
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            可选链 “?.” 可选链 ?. 是一种访问嵌套对象属性的防错误方法。即使中间的属性不存在，也不会出现错误。
let user = {}; // 这个 user 恰巧没有 addressalert(user?.address); // undefined!alert(user?.address.street); // undefined! 不要过度使用可选链 我们应该只将 ?. 使用在一些东西可以不存在的地方。  例如，如果根据我们的代码逻辑，user 对象必须存在，但 address 是可选的，那么 user.address?.street 会更好。
所以，如果 user 恰巧因为失误变为 undefined，我们会知道并修复这个失误。否则，代码中的 error 在不恰当的地方被消除了，这会导致调试更加困难。
?. 前的变量必须已声明 如果未声明变量 user，那么 user?.anything 会触发一个错误：
// ReferenceError: user is not defined user?.address;
短路效应 正如前面所说的，如果 ?. 左边部分不存在，就会立即停止运算（“短路效应”）。
所以，如果后面有任何函数调用或者副作用，它们均不会执行：
其它情况：?.()，?.[] 可选链 ?. 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。
例如，将 ?.() 用于调用一个可能不存在的函数。
在下面这段代码中，有些用户具有 admin 方法，而有些没有：
let user1 = {admin() {alert(&quot;I am admin&quot;);}}let user2 = {};user1.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-optional-chaining/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/course-stanford/">Course Stanford</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-16
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            math 51 多维微积分 <a href="http://web.stanford.edu/class/math51">http://web.stanford.edu/class/math51</a>
EE 103 线性代数 <a href="http://web.stanford.edu/class/ee103">http://web.stanford.edu/class/ee103</a>
CS 109 概率论 <a href="http://web.stanford.edu/class/cs109">http://web.stanford.edu/class/cs109</a>
CS 106 A 程序设计基础 <a href="http://web.stanford.edu/class/cs106a">http://web.stanford.edu/class/cs106a</a>
CS 106 B 程序设计基础 <a href="http://web.stanford.edu/class/cs106b">http://web.stanford.edu/class/cs106b</a>
CS 107 计算机系统导论 <a href="http://web.stanford.edu/class/cs107">http://web.stanford.edu/class/cs107</a>
CS 140 操作系统 <a href="http://web.stanford.edu/class/cs145">http://web.stanford.edu/class/cs145</a>
CS 143 编译器 <a href="http://web.stanford.edu/class/cs143">http://web.stanford.edu/class/cs143</a>
CS 145 数据库导论 <a href="http://web.stanford.edu/class/cs145">http://web.stanford.edu/class/cs145</a>
CS 149 并行计算 <a href="http://web.stanford.edu/class/cs149">http://web.stanford.edu/class/cs149</a>
CS 161 算法设计与分析 <a href="http://web.stanford.edu/class/cs161">http://web.stanford.edu/class/cs161</a>
CS 221 人工智能导论 http://web.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/course-stanford/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-module/">Js Module</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-16
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            JavaScript 很长一段时间内都没有语言级（language-level）的模块语法。这不是一个问题，因为最初的脚本又小又简单，所以没必要将其模块化。
但是最终脚本变得越来越复杂，因此社区发明了许多种方法来将代码组织到模块中，使用特殊的库按需加载模块。
AMD —— 最古老的模块系统之一，最初由 require.js 库实现。 CommonJS —— 为 Node.js 服务器创建的模块系统。 UMD —— 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容。
语言级的模块系统在 2015 年的时候出现在了标准（ES6）中，此后逐渐发展，现在已经得到了所有主流浏览器和 Node.js 的支持。因此，我们将从现在开始学习现代 JavaScript 模块（module）。
什么是模块？  export 关键字标记了可以从当前模块外部访问的变量和函数。 import 关键字允许从其他模块导入功能。  // sayHi.jsexport function sayHi(user) {alert(<code>Hello, ${user}!</code>);}// 📁 main.jsimport {sayHi} from './sayHi.js';alert(sayHi); // function&hellip;sayHi('John'); // Hello, John!由于模块支持特殊的关键字和功能，因此我们必须通过使用 &lt;script type=&quot;module&quot;&gt; 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。
&lt;!doctype html&gt;&lt;script type=&quot;module&quot;&gt;import {sayHi} from './say.js';document.body.innerHTML = sayHi('John');&lt;/script&gt;浏览器会自动获取并解析（evaluate）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-module/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/linux-what/">Linux What</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-14
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/linux-what/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/web-data-storage/">Web Data Storage</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-14
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            Cookie Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分，由 RFC 6265 规范定义。
Cookie 通常是由 Web 服务器使用响应 Set-Cookie HTTP-header 设置的。然后浏览器使用 Cookie HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中
最常见的用处之一就是身份验证：
登录后，服务器在响应中使用 Set-Cookie HTTP-header 来设置具有唯一“会话标识符（session identifier）”的 cookie。 下次如果请求是由相同域发起的，浏览器会使用 Cookie HTTP-header 通过网络发送 cookie。 所以服务器知道是谁发起了请求。
alert(document.cookie)写入 document.cookie
document.cookie = &quot;user=John&quot;; // 只会更新名称为 user 的 cookiealert(document.cookie); // 展示所有 cookie从技术上讲，cookie 的名称和值可以是任何字符，为了保持有效的格式，它们应该使用内建的 encodeURIComponent 函数对其进行转义：
// 特殊字符（空格），需要编码let name = &quot;my name&quot;;let value = &quot;John Smith&quot;// 将 cookie 编码为 my%20name=John%20Smithdocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);alert(document.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/web-data-storage/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/web-components/">Web Components</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-14
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            众所周知，开发复杂软件的原则是：不要让软件复杂
如果某个部分变得复杂了 —— 将其拆分成更简单的部分，再以最简明的方式组合起来。
只有让复杂的事情简单化的架构才是好架构。
一个组件有：
自己的 JavaScript 类。 DOM 结构，并且只由自己的类管理，无法被外部代码操作。（「封装」原则）。 CSS 样式，作用在这个组件上。 API：事件，类方法等等，让组件可以与其他组件交互。
Custom elements —— 用于自定义 HTML 元素. Shadow DOM —— 为组件创建内部 DOM，它对外部是不可见的。 CSS Scoping —— 申明仅应用于组件的 Shadow DOM 内的样式。 Event retargeting 以及更多的小东西，让自定义组件更适用于开发工作。
Custom elements (自定义标签) class MyElement extends HTMLElement {constructor() {super();// 元素在这里创建 }connectedCallback() {// 在元素被添加到文档之后，浏览器会调用这个方法 //（如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用） }disconnectedCallback() {// 在元素从文档移除到时候，浏览器会调用这个方法 // （如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用） }static get observedAttributes() {return [/* 属性数组，这些属性的变化会被被监视 */];}attributeChangedCallback(name, oldValue, newValue) {// 当上面数组里面的属性变化的时候，这个方法会被调用 }adoptedCallback() {// 在元素被移动到新的文档的时候，这个方法会被调用 // （document.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/web-components/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/good-doctor-1-3/">Good Doctor 1 3</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-13
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            良医 第一季 第三集 01:35
so I’m in the middle of (正忙于) “Uncharted”, and I’m dead
我正在玩无人之地，但是没电了
Can I borrow some triples A’s
能借几节7号电池吗
I’m your neighbor
我是你的邻居
hello
你好
34 ?
34号
I moved in last week. 33.
我上周搬来，33号
yeah， I know
是 我知道
I work at a hospital
我在医院工作
That’s cool
很酷
yes
是
Triple A’s pro favor ?
7号电池 拜托
Batteries
电池
Right
没错
Do you hava any ?
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/good-doctor-1-3/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-regexp/">Js Regexp</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-13
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            正则表达式 在 JavaScript 中，正则表达式通过内置的“RegExp”类的对象来实现，并与字符串集成。
创建正则表达式有两个方式
// new RegExpregexp = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);// 表达式regexp = /pattern/; // 没有修饰符regexp = /pattern/gmi; // 伴随修饰符 g、m 和 i（后面会讲到）用法
字符串搜索
let str = &quot;I love Javascript&quot;;let substr = 'love';alert(str.search(substr));所以搜索 /love/ 与搜索 “love” 是等价的。
通常我们使用的都是简短语法 /…/。但是它不接受任何变量插入，所以我们必须在写代码的时候就知道确切的 regexp。
另一方面，new RegExp 允许从字符串中动态地构造模式。
所以我们可以找出需要搜索的字段，然后根据搜索字段创建 new RegExp：
// 弹窗提示框, 默认输入值lovelet search = prompt(&quot;What you want to search?&quot;, &quot;love&quot;); // love// let regexp = new RegExp(search);// 找到用户想要的任何东西alert( &quot;I love JavaScript&quot;.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-regexp/">Read more →</a></div>
      
    </div>
    
    <div class="pagination">
  <div class="pagination__buttons">
    
      <span class="button previous">
        <a href="/page/3/">
          <span class="button__icon">←</span>
          <span class="button__text">Newer posts</span>
        </a>
      </span>
    
    
      <span class="button next">
        <a href="/page/5/">
          <span class="button__text">Older posts</span>
          <span class="button__icon">→</span>
        </a>
      </span>
    
  </div>
</div>

  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Copyright©2019-2020 Strawbreey. All Rights Reserved</div>
      
  </div>
</footer>

<script src="/assets/main.js"></script>



      
    </div>

    
  </body>
</html>

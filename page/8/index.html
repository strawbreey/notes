<!DOCTYPE html>
<html lang="en">
  <head>
	<meta name="generator" content="Hugo 0.67.0-DEV" />
    
      <title>
        Strawbreey Notes
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content=""
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="/" />





<link rel="stylesheet" href="/assets/style.css" />

<link rel="stylesheet" href="/style.css" />


<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/styles/atom-one-dark.min.css">

<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="/favicon.png" />





<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Strawbreey Notes"/>
<meta name="twitter:description" content=""/>



<meta property="og:title" content="Strawbreey Notes" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />
<meta property="og:updated_time" content="2020-08-28T19:17:20+08:00" /><meta property="og:site_name" content="Strawbreey Notes" />



<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Strawbreey Notes" />



  </head>
  <body class="">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    
    <span class="logo__text">
      Strawbreey Notes
    </span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/showcase">Showcase</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  
  
    
  
  

  

  <div class="posts">
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/front-end-interview-standard/">Front End Interview Standard</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-09
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            不同公司，不同岗位，不同业务背景对优秀前端的要求可能会有差异，以阿里巴巴淘系技术部的一则JD为例，来拆解一下，不同级别的前端工程师应该具备什么样的技能。
JD业务背景淘宝内部最大创新项目之一，大团队已有百人规模，大部分项目处于保密阶段，前景远大职位描述:
负责组件库与业务页面开发。 带领团队完成技术产品实现。 负责大型多应用架构设计。 利用前端技术与服务端协同完成团队业务目标。  职位要求:
掌握图形学，webgl或熟练使用threejs框架，熟练canvas相关渲染及动画操作的优先。 熟练掌握JavaScript。 熟悉常用工程化工具，掌握模块化思想和技术实现方案。 熟练掌握React前端框架，了解技术底层。同时了解vue以及angular等其他框架者优先。 熟练掌握react生态常用工具，redux/react-router等。 熟悉各种Web前端技术，包括HTML/XML/CSS等，有基于Ajax的前端应用开发经验。 有良好的编码习惯，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和各种背景的人合作。 具有TS/移动设备上前端开发/NodeJS/服务端开发等经验者优先。  首先，总览全部的要求，会发现这个职位虽然提到了3d相关的技能，但是大部分却是应用开发相关的能力，所以这个职位并不是想找专业的3d领域同学，而是需要一个工程化能力强，对3d有了解的同学。
掌握图形学，  webgl或熟练使用threejs框架，熟练canvas相关渲染及动画操作的优先。
初级：学习过图形学相关知识，知道矩阵等数学原理在动画中的作用，知道三维场景需要的最基础的构成，能用threejs搭3d场景，知道webgl和threejs的关系。知道canvas是干嘛的，聊到旋转能说出canvas的api。知道css动画，css动画属性知道关键字和用法(换句话说，电话面试会当场出题要求口喷css动画，至少能说对大概，而不是回答百度一下就会用)。知道js动画，能说出1~2个社区js动画库，知道js动画和css动画优缺点以及适用场景。知道raf和其他达到60fps的方法。
中级：如果没有threejs，你也能基于webgl自己封装一个简单的threejs出来。聊到原理能说出四元数，聊到鼠标操作能提到节流，聊到性能能提到restore，聊到帧说出raf和timeout的区别，以及各自在优化时候的作用。知道怎样在移动端处理加载问题，渲染性能问题。知道如何结合native能力优化性能。知道如何排查性能问题。对chrome动画、3d、传感器调试十分了解。
高级：搭建过整套资源加载优化方案，能说明白整体方案的各个细节，包括前端、客户端、服务端分别需要实现哪些功能点、依赖哪些基础能力，以及如何配合。设计并实现过前端动画引擎，能说明白一个复杂互动项目的技术架构，知道需要哪些核心模块，以及这些模块间如何配合。有自己实现的动画相关技术方案产出，这套技术方案必须是解决明确的业务或技术难点问题的。为了业务快速落地而封装一个库，不算这里的技术方案。如果有类似社区方案，必须能从原理上说明白和竞品的差异，各自优劣，以及技术选型的原因。
熟练掌握JavaScript。    初级：JavaScript各种概念都得了解，《JavaScript语言精粹》这本书的目录都得有概念，并且这些核心点都能脱口而出是什么。这里列举一些做参考：知道组合寄生继承，知道class继承。知道怎么创建类function + class。知道闭包在实际场景中怎么用，常见的坑。知道模块是什么，怎么用。知道event loop是什么，能举例说明event loop怎么影响平时的编码。掌握基础数据结构，比如堆、栈、树，并了解这些数据结构计算机基础中的作用。知道ES6数组相关方法，比如forEach，map，reduce, 及实现。
中级：知道class继承与组合寄生继承的差别，并能举例说明。知道event loop原理，知道宏微任务，并且能从个人理解层面说出为什么要区分。知道node和浏览器在实现loop时候的差别。能将继承、作用域、闭包、模块这些概念融汇贯通，并且结合实际例子说明这几个概念怎样结合在一起。能脱口而出2种以上设计模式的核心思想，并结合js语言特性举例或口喷基础实现。掌握一些基础算法核心思想或简单算法问题，比如排序，大数相加。
熟悉常用工程化工具，掌握模块化思想和技术实现方案。    初级：知道webpack，rollup以及他们适用的场景。知道webpack v4和v3的区别。脱口而出webpack基础配置。知道webpack打包结果的代码结构和执行流程，知道index.js，runtime.js是干嘛的。知道amd，cmd，commonjs，es module分别是什么。知道所有模块化标准定义一个模块怎么写。给出2个文件，能口喷一段代码完成模块打包和执行的核心逻辑。
中级：知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。了解异步模块加载的实现原理，能口喷代码实现核心逻辑。
高级：能设计出或具体说明白团队研发基础设施。具体包括但不限于：项目脚手架搭建，及如何以工具形态共享。团队eslint规范如何设计，及如何统一更新。工具化打包发布流程，包括本地调试、云构建、线上发布体系、一键部署能力。同时，方案不仅限于前端工程部分，包含相关服务端基础设施，比如cdn服务搭建，接入层缓存方案设计，域名管控等。客户端缓存及预加载方案。
3.熟练掌握React前端框架，了解技术底层。同时了解vue以及angular等其他框架者优先。
初级：知道react常见优化方案，脱口而出常用生命周期，知道他们是干什么的。知道react大致实现思路，能对比react和js控制原生dom的差异，能口喷一个简化版的react。知道diff算法大致实现思路。对state和props有自己的使用心得，结合受控组件、hoc等特性描述，需要说明各种方案的适用场景。以上几点react替换为vue或angular同样适用。
中级：能说明白为什么要实现fiber，以及可能带来的坑。能说明白为什么要实现hook。能说明白为什么要用immutable，以及用或者不用的考虑。知道react不常用的特性，比如context，portal。能用自己的理解说明白react like框架的本质，能说明白如何让这些框架共存。
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/front-end-interview-standard/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/nestjs-tutorial/">Nestjs Tutorial</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-08
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/nestjs-tutorial/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/nestjs-deploy/">Nestjs Deploy</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-08
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/nestjs-deploy/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/beego/">Beego</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-10-08
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            deploy 通过 bee 创建的项目，beego 默认情况下是开发模式。
我们可以通过如下的方式改变我们的模式：
beego.RunMode = &quot;prod&quot;或者我们在 conf/app.conf 下面设置如下：
runmode = prod发行部署
Go 语言的应用最后编译之后是一个二进制文件，你只需要 copy 这个应用到服务器上，运行起来就行。beego 由于带有几个静态文件、配置文件、模板文件三个目录，所以用户部署的时候需要同时 copy 这三个目录到相应的部署应用之下，下面以我实际的应用部署为例：
独立部署
独立部署即为在后端运行程序，让程序跑在后台。
在 linux 下面部署，我们可以利用 nohup 命令，把应用部署在后端，如下所示：
nohup ./beepkg &amp;Windows 在 Windows 系统中，设置开机自动，后台运行，有如下几种方式：
制作 bat 文件，放在“启动”里面 制作成服务
nginx 部署
server {listen 80;server_name .a.com;charset utf-8;access_log /home/a.com.access.log;location /(css|js|fonts|img)/ {access_log off;expires 1d;root &quot;/path/to/app_a/static&quot;;try_files $uri @backend;}location / {try_files /<em>not_exists</em> @backend;}location @backend {proxy_set_header X-Forwarded-For $remote_addr;proxy_set_header Host $http_host;proxy_pass http://127.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/beego/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-array-helper/">Js Array Helper</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-28
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-array-helper/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-array/">Js Array</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-28
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            Array.from() // Syntax// arrayLike: An array-like or iterable object to convert to an array.// mapFn Optional: Map function to call on every element of the array.// thisArg Optional: Value to use as this when executing mapFn.// return value: A new Array instance.Array.from(arrayLike [, mapFn [, thisArg]])console.log(Array.from('foo'));// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6]Array.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-array/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/js-deep-copy/">Js Deep Copy</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            JSON.parse/stringify if you do not use Date, function, undefined, Infinity, RegFexps, Maps, Set Blobs, FileList，ImageData， sparseArray,Typed Array or other complex type within you object。
如果不使用复制的数据类型, JSON序列化是最快的复制方法
JSON.parse(JSON.stringify(object))const a = {string: 'string',number: 123,bool: false,nul: null,date: new Date(), // stringified undef: undefined, // lost inf: Infinity, // forced to 'null' re: /.*/, // lost}console.log(a);console.log(typeof a.date); // Date objectconst clone = JSON.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/js-deep-copy/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/swagger-php/">Swagger Php</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/swagger-php/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/chrome-devtools/">Chrome Devtools</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/chrome-devtools/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/http-status-code/">Http Status Code</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)。状态代码由 section 10 of RFC 2616定义
信息响应 100 Continue
这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。
101 Switching Protocol
该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。
102 Processing (WebDAV)
此代码表示服务器已收到并正在处理该请求，但没有响应可用。
103 Early Hints
此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。
成功响应 200 OK
请求成功。成功的含义取决于HTTP方法：
GET：资源已被提取并在消息正文中传输。 HEAD：实体标头位于消息正文中。 POST：描述动作结果的资源在消息体中传输。 TRACE：消息正文包含服务器收到的请求消息  201 Created
该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。
202 Accepted
请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。
203 Non-Authoritative Information
服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。
204 No Content
服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。
205 Reset Content
服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。
206 Partial Content
服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/http-status-code/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/hugo-install/">Hugo Install</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            If you are on a Windows machine and use Chocolatey for package management, you can install Hugo with the following one-liner
more # install-with-chocolatey.ps1choco install hugo -confirm# Or if you need the “extended” Sass/SCSS version:choco install hugo-extended -confirmIf you are on a Windows machine and use Scoop for package management, you can install Hugo with the following one-liner:
scoop install hugo# Or install the extended version with:scoop install hugo-extendedSource
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/hugo-install/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/http-cache/">Http Cache</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            Http 缓存 通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP缓存，变得更加响应性。
不同种类的缓存 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。
缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。
浏览器缓存 (私有) 私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。
代理缓存 (共享) 共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。
缓存操作 虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。 普遍的缓存案例:
一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。
永久重定向: 响应状态码：301。
错误响应: 响应状态码：404 的一个页面。
不完全的响应: 响应状态码 206，只返回局部的信息。
除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应。
缓存控制  没有缓存  缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
Cache-Control: no-store缓存但重新验证  如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。
Cache-Control: no-cache私有和公共缓存  “public” 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了&quot;public”，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/http-cache/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/memcached/">Memcached</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/memcached/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/cors/">Cors</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            跨源资源共享 (CORS: Cross-origin resource sharing) （或通俗地译为跨域资源共享）是一种机制，该机制使用附加的 HTTP 头来告诉浏览器，准许运行在一个源上的Web应用访问位于另一不同源选定的资源。 当一个Web应用发起一个与自身所在源（域，协议和端口）不同的HTTP请求时，它发起的即跨源HTTP请求。
出于安全性，浏览器限制脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。
跨源域资源共享（ CORS ）机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨源 HTTP 请求所带来的风险。
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）
简单请求 （1) 请求方法是以下三种方法之一：
HEAD GET POST  （2）HTTP的头信息不超出以下几种字段：
Accept Accept-Language Content-Language Last-Event-ID Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain  这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。
对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。
GET /cors HTTP/1.1Origin: <a href="http://api.bob.com">http://api.bob.com</a>Host: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0&hellip;上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/cors/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/es6-symbol/">Es6 Symbol</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/es6-symbol/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/typescript-tutorial/">Typescript Tutorial</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。
Install Typescript function sayHello(person: string) {return 'Hello, ' + person;}let user = 'Tom';console.log(sayHello(user));npm install -g typescripttsc hello.tsdata type JavaScript 的数据类型分为两种: 基本数据类型和复杂数据类型
基本数据类型:
Undefined
Null
Boolean
Number
String
Symbol (ES6) symbol 是ES6中新增的一种特殊的、不可变的基本数据类型（primitive data type），可以作为对象属性的标识符使用
Tuple (TS) 元组 (元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同)
Enum (TS) 枚举
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/typescript-tutorial/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/webpack-tutoral/">Webpack Tutoral</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-27
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/webpack-tutoral/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/hot-module-replacement/">Hot Module Replacement</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-25
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            浏览器刷新页面的方法 Location.reload // 语法location.reload([forcedReload])// demowindow.location.reload(true);forcedReload 可选 该参数要求为 布尔 类型，当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。
无缓存刷新页面但页面引用的资源还是可能使用缓存，大多数浏览器可以通过设置在打开开发者工具时禁用缓存实现无缓存需求）
Location.replace // 语法object.replace(url);// demodocument.location.replace('https://developer.mozilla.org/en-US/docs/Web/API/Location/reload');Location.replace() 方法以给定的URL来替换当前的资源。 与assign() 方法 不同的是，调用 replace() 方法后，当前页面不会保存到会话历史中（session History），这样，用户点击回退按钮时，将不会再跳转到该页面。
因违反安全规则导致的赋值失败，浏览器将会抛出类型为 SECURITY_ERROR 的 DOMException 异常。当调用该方法的脚本所属的源与拥有 Location 对象所属源不同时，通常情况会发生这种异常,此时通常该脚本是存在不同的域下。
Location.assign // 语法location.assign(url);// demodocument.location.assign('https://developer.mozilla.org/zh-CN/docs/Web/API/Location/reload');Location.assign 方法会触发窗口加载并显示指定的URL的内容。 如果由于安全原因无法执行跳转，那么会抛出一个 SECURITY_ERROR 类型的 DOMException。当调用此方法的脚本来源和页面的 Location 对象中定义的来源隶属于不同域的时候，就会抛出上述错误
JavaScript刷新页面的几种方法 history.go(0)location.reload()location=locationlocation.assign(location)document.execCommand('Refresh')window.navigate(location)location.replace(location)document.URL=location.href自动刷新页面的方法 &lt;!&ndash; 页面自动刷新 &ndash;&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;&lt;!
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/hot-module-replacement/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/git-tutorial/">Git Tutorial</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-24
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
Git 配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量（由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）。
~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。
当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 –local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它（当然，你需要进入某个 Git 仓库中才能让该选项生效）。
每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
查看git所有配置以及他所在的文件
git config &ndash;list &ndash;show-origin用户信息 # 设置全局的用户信息$ git config &ndash;global user.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/git-tutorial/">Read more →</a></div>
      
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/php-array-helper/">Php Array Helper</a></h1>
      <div class="post-meta">
        
          <span class="post-date">
            2020-09-24
          </span>

          
        

        

        
      </div>

      

      

      <div class="post-content">
        
          
            获取值 getValue() 用原生PHP从一个对象、数组、或者包含这两者的一个复杂数据结构中获取数据是非常繁琐的。 你首先得使用 isset 检查 key 是否存在, 然后如果存在你就获取它，如果不存在， 则提供一个默认返回值：
class User{public $name = 'Alex';}$array = ['foo' =&gt; ['bar' =&gt; new User(),]];$value = isset($array['foo']['bar']-&gt;name) ? $array['foo']['bar']-&gt;name : null;// or$value = ArrayHelper::getValue($array, 'foo.bar.name');// 方法的第一个参数是我们从哪里获取值。第二个参数指定了如何获取数据， 它可以是下述几种类型中的一个：// 数组键名或者欲从中取值的对象的属性名称；// 以点号分割的数组键名或者对象属性名称组成的字符串，上例中使用的参数类型就是该类型；// 返回一个值的回调函数。$fullName = ArrayHelper::getValue($user, function ($user, $defaultValue) {return $user-&gt;firstName . ' ' . $user-&gt;lastName;});// 第三个可选的参数如果没有给定值，则默认为 null，如下例所示：$username = ArrayHelper::getValue($comment, 'user.
          
        
      </div>
      
        <div><a class="read-more button" href="/posts/php-array-helper/">Read more →</a></div>
      
    </div>
    
    <div class="pagination">
  <div class="pagination__buttons">
    
      <span class="button previous">
        <a href="/page/7/">
          <span class="button__icon">←</span>
          <span class="button__text">Newer posts</span>
        </a>
      </span>
    
    
      <span class="button next">
        <a href="/page/9/">
          <span class="button__text">Older posts</span>
          <span class="button__icon">→</span>
        </a>
      </span>
    
  </div>
</div>

  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Copyright©2019-2020 Strawbreey. All Rights Reserved</div>
      
  </div>
</footer>

<script src="/assets/main.js"></script>

<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


      
    </div>

    
  </body>
</html>

<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Git Tutorial - My New Hugo Site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="olOwOlo" /><meta name="description" content="本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
Git 配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
  /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 &amp;ndash;system 选项，那么它就会读写该文件中的配置变量（由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）。
  ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 &amp;ndash;global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。
  当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 &amp;ndash;local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它（当然，你需要进入某个 Git 仓库中才能让该选项生效）。
  每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
查看git所有配置以及他所在的文件
git config --list --show-origin 用户信息 # 设置全局的用户信息 $ git config --global user." />






<meta name="generator" content="Hugo 0.86.0-DEV with theme even" />


<link rel="canonical" href="https://example.org/posts/git/git-tutorial/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">



<meta property="og:title" content="Git Tutorial" />
<meta property="og:description" content="本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
Git 配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
  /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 &ndash;system 选项，那么它就会读写该文件中的配置变量（由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）。
  ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 &ndash;global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。
  当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 &ndash;local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它（当然，你需要进入某个 Git 仓库中才能让该选项生效）。
  每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
查看git所有配置以及他所在的文件
git config --list --show-origin 用户信息 # 设置全局的用户信息 $ git config --global user." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.org/posts/git/git-tutorial/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-24T19:29:58+08:00" />
<meta property="article:modified_time" content="2020-09-24T19:29:58+08:00" />

<meta itemprop="name" content="Git Tutorial">
<meta itemprop="description" content="本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
Git 配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
  /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 &ndash;system 选项，那么它就会读写该文件中的配置变量（由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）。
  ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 &ndash;global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。
  当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 &ndash;local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它（当然，你需要进入某个 Git 仓库中才能让该选项生效）。
  每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
查看git所有配置以及他所在的文件
git config --list --show-origin 用户信息 # 设置全局的用户信息 $ git config --global user."><meta itemprop="datePublished" content="2020-09-24T19:29:58+08:00" />
<meta itemprop="dateModified" content="2020-09-24T19:29:58+08:00" />
<meta itemprop="wordCount" content="722">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Git Tutorial"/>
<meta name="twitter:description" content="本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
Git 配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
  /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 &ndash;system 选项，那么它就会读写该文件中的配置变量（由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）。
  ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 &ndash;global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。
  当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 &ndash;local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它（当然，你需要进入某个 Git 仓库中才能让该选项生效）。
  每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
查看git所有配置以及他所在的文件
git config --list --show-origin 用户信息 # 设置全局的用户信息 $ git config --global user."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">My New Hugo Site</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">My New Hugo Site</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <h3 id="本地版本控制系统">本地版本控制系统</h3>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>
<p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
<h3 id="git-配置">Git 配置</h3>
<p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ul>
<li>
<p>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 &ndash;system 选项，那么它就会读写该文件中的配置变量（由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）。</p>
</li>
<li>
<p>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 &ndash;global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。</p>
</li>
<li>
<p>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 &ndash;local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它（当然，你需要进入某个 Git 仓库中才能让该选项生效）。</p>
</li>
</ul>
<p>每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p>
<p>查看git所有配置以及他所在的文件</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git config --list --show-origin
</code></pre></div><h3 id="用户信息">用户信息</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 设置全局的用户信息</span>
$ git config --global user.name <span style="color:#e6db74">&#34;John Doe&#34;</span>
$ git config --global user.email johndoe@example.com

<span style="color:#75715e"># 设置项目的用户信息</span>
$ git config user.name <span style="color:#e6db74">&#34;John Doe&#34;</span>
$ git config user.email johndoe@example.com

</code></pre></div><h3 id="检查配置信息">检查配置信息</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 检查git配置信息</span>
git config --list

<span style="color:#75715e"># git config &lt;key&gt;： 来检查 Git 的某一项配置</span>
git config user.name

<span style="color:#75715e"># 检查git配置信息和其配置地址</span>
git config --list --show-origin
</code></pre></div><h3 id="获取git仓库">获取Git仓库</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">
<span style="color:#75715e"># 在已存在目录中初始化仓库</span>
<span style="color:#75715e"># 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</span>
git init

<span style="color:#75715e"># 添加提交记录</span>
git add *.c
git add LICENSE
git commit -m <span style="color:#e6db74">&#39;initial project version&#39;</span>

<span style="color:#75715e"># 克隆现有的仓库</span>
git clone https://github.com/libgit2/libgit2

<span style="color:#75715e"># 克隆仓库并重命名</span>
git clone https://github.com/libgit2/libgit2 mylibgit
</code></pre></div><h2 id="git-状态变化周期">git 状态变化周期</h2>
<p><img src="/images/lifecycle.png" alt="lifecycle"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">
<span style="color:#75715e"># 检查当前文件状态</span>
git status 

<span style="color:#75715e"># 添加跟踪文件</span>
git add README

<span style="color:#75715e"># 简述</span>
git status -s
git status -short

<span style="color:#75715e"># 忽略文件</span>
.gitignone
</code></pre></div><p>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>
<p>所有空行或者以 # 开头的行都会被 Git 忽略。</p>
</li>
<li>
<p>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</p>
</li>
<li>
<p>匹配模式可以以（/）开头防止递归。</p>
</li>
<li>
<p>匹配模式可以以（/）结尾指定目录。</p>
</li>
<li>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 忽略所有的 .a 文件</span>
*.a

<span style="color:#75715e"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span>
!lib.a

<span style="color:#75715e"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span>

<span style="color:#75715e"># 忽略任何目录下名为 build 的文件夹</span>
build/

<span style="color:#75715e"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span>
doc/*.txt

<span style="color:#75715e"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span>
doc/**/*.pdf
</code></pre></div><p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 要查看尚未暂存的文件更新了哪些部分</span>
git diff
</code></pre></div><h4 id="查看提交历史">查看提交历史</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log

<span style="color:#75715e"># 查看最近2次提交补丁</span>
git log -p -2

<span style="color:#75715e"># 查看简略提示信息</span>
git log --stat

<span style="color:#75715e"># </span>
git log --pretty<span style="color:#f92672">=</span>oneline
</code></pre></div><h4 id="撤销操作">撤销操作</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">
<span style="color:#75715e"># 提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令来重新提交</span>
git commit --amend

git status
git reset HEAD CONTRIBUTING.md

git checkout -- CONTRIBUTING.md
git status

<span style="color:#75715e"># 撤销 HEAD^的意思是上一个版本 也可以写成HEAD~1</span>
git reset --soft HEAD^ 
<span style="color:#75715e"># 等同</span>
git reset --mixed HEAD^

<span style="color:#75715e"># 删除工作空间改动代码，撤销commit，撤销git add .</span>
git reset --hard HEAD^
</code></pre></div><p>记住，在 Git 中任何 已提交 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 &ndash;amend 选项覆盖的提交也可以恢复 （阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p>
<h3 id="远程仓库使用">远程仓库使用</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone https://github.com/schacon/ticgit

cd ticgit

<span style="color:#75715e"># 查看你已经配置的远程仓库服务器</span>
git remote

<span style="color:#75715e"># 需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span>
git remote -v

<span style="color:#75715e"># 添加远程仓库</span>
git remote
git remote add pb https://github.com/paulboone/ticgit
git remote -v

<span style="color:#75715e"># 现在你可以在命令行中使用字符串 pb 来代替整个 URL</span>
git fetch pb

<span style="color:#75715e">#  必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。</span>

<span style="color:#75715e"># 推送到远程仓库, 当你想要将 master 分支推送到 origin 服务器时</span>
git push origin master

<span style="color:#75715e"># 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送</span>

<span style="color:#75715e"># 查看某个远程仓库, 可以使用 git remote show &lt;remote&gt; 命令</span>

git remote show origin <span style="color:#75715e"># </span>

<span style="color:#75715e"># 远程仓库的重命名与移除</span>
git remote rename pb paul <span style="color:#75715e"># 修改一个远程仓库的简写名</span>
git remote remove paul <span style="color:#75715e"># 移除一个远程仓库</span>
</code></pre></div><h3 id="打标签">打标签</h3>
<p>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）</p>
<h4 id="列出标签">列出标签</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 列出标签</span>
git tag

<span style="color:#75715e"># 按照特定的模式查找标签</span>
git tag -l <span style="color:#e6db74">&#34;v1.8.5*&#34;</span>
</code></pre></div><h4 id="创建标签">创建标签</h4>
<p>git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）</p>
<p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p>
<p>附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 轻量标签</span>
git tag v1.4-lw

<span style="color:#75715e"># 创建附注标签</span>
git tag -a v1.4 -m <span style="color:#e6db74">&#34;my version 1.4&#34;</span> <span style="color:#75715e"># -m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</span>

git show <span style="color:#75715e"># 看到标签信息和与之对应的提交信息</span>

<span style="color:#75715e"># 对过去的提交打标签</span>
git tag -a v1.2 9fceb02

<span style="color:#75715e"># 共享标签</span>
git push origin v1.5

<span style="color:#75715e"># 一次性推送很多标签</span>
git push origin --tags

<span style="color:#75715e"># 删除标签</span>
git tag -d &lt;tagname&gt;

<span style="color:#75715e"># 删除远程标签 将冒号前面的空值推送到远程标签名，从而高效地删除它。</span>
git push origin :refs/tags/v1.4-lw
<span style="color:#75715e"># or</span>
git push origin --delete &lt;tagname&gt;

<span style="color:#75715e"># 从标签中迁出分支</span>
git checkout -b version2 v2.0.0
</code></pre></div><h3 id="别名">别名</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 设置别名</span>
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
</code></pre></div><h2 id="git-分支">Git 分支</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 追踪系统中的 #53 问题</span>
git checkout -b iss53
<span style="color:#75715e"># or</span>
git branch iss53
git checkout iss53

<span style="color:#75715e"># 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。</span>
git stash

git checkout master

<span style="color:#75715e"># 切换一个紧急分支, 并修复bug</span>
git checkout -b hotfix

<span style="color:#75715e"># 切回master</span>
git checkout master

<span style="color:#75715e"># 合并hotfix分支</span>
git merge hotfix

<span style="color:#75715e"># 删除hotfix分支</span>
git branch -d hotfix

<span style="color:#75715e"># 返回iss53, 修复bug</span>
git checkout iss53
git checkout master
git merge iss53
git branch -d iss53

<span style="color:#75715e"># 查看所有分支</span>
git branch -a

<span style="color:#75715e"># 切换远程分支</span>
<span style="color:#75715e"># git checkout -b 本地分支名 origin/远程分支名</span>
git checkout -b test origin/test


<span style="color:#75715e"># 将本地分支推送到远程</span>
<span style="color:#75715e"># git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span>
git push -u origin dev:release/caigou_v1.0

</code></pre></div><h4 id="分支管理">分支管理</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 查看分支</span>
git branch

<span style="color:#75715e"># 查看每一个分支的最后一次提交</span>
git branch -v 

<span style="color:#75715e"># --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。</span>
git branch --merged
git branch --no-merged

<span style="color:#75715e"># 当删除其他还未合并的分支时, 会失败</span>
</code></pre></div><h3 id="远程分支">远程分支</h3>
<blockquote>
<p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。</p>
</blockquote>
<p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote <!-- raw HTML omitted --> 来显式地获得远程引用的完整列表， 或者通过 git remote show <!-- raw HTML omitted --> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
<h4 id="变基-vs-合并">变基 vs. 合并</h4>
<p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>
<p>有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
<p>另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<h2 id="git-协议">Git 协议</h2>
<p>Git 可以使用四种不同的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p>
<h3 id="在服务器上搭建git">在服务器上搭建Git</h3>
<h3 id="生成ssh公钥">生成ssh公钥</h3>
<p>许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd ~/.shh
</code></pre></div><h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://git-scm.com/book/zh/v2">pro git book</a></li>
</ul>

  </div>
</article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://example.org/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
     - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>olOwOlo</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>

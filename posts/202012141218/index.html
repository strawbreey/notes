<!DOCTYPE html>
<html><head>
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

   
    <meta name="author" content="Sukoshi">
  

   
    
    
    
    
    
    
    <meta name="keywords" content="theme,kagome">
  

  

  <meta name="generator" content="Hugo 0.86.0" />
  
  
  
  
  
  
  <title>Go Example 🌟 梨花细雨不见鹿2</title>

  <meta property="og:title" content="Go Example" />
<meta property="og:description" content="1. 编译 package main import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world&#34;) } 要运行这个程序，将这些代码放到 hello-world.go 中并且使用 go run 命令。 go run hello-world.go hello world 有时候我们想将我们的程序编译成二进制文件。我们可以通" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://note.strawbreey.com/posts/202012141218/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-14T12:18:37+08:00" />
<meta property="article:modified_time" content="2020-12-14T12:18:37+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go Example"/>
<meta name="twitter:description" content="1. 编译 package main import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world&#34;) } 要运行这个程序，将这些代码放到 hello-world.go 中并且使用 go run 命令。 go run hello-world.go hello world 有时候我们想将我们的程序编译成二进制文件。我们可以通"/>


  <link href="https://note.strawbreey.com/css/index.css" rel="stylesheet">    

  <script src="https://note.strawbreey.com/js/main.js" ></script>
  
  </head><body><header class="header-container layout-block layout-padding">
  <div class="header-inner content-padding-large soft-size--large soft-style--box">
    <div class="header-logo">
      <a href="https://note.strawbreey.com"><h1>梨花细雨不见鹿2</h1></a>
    </div>
    <nav class="header-nav">
      <div class="header-nav--btn">
        <div class="btn-item"></div>
        <div class="btn-item"></div>
        <div class="btn-item"></div>
      </div>
      <div class="header-nav--list">
        <div>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/" title="">HOME</a>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/posts" title="">POSTS</a>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/message" title="">MESSAGE</a>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/link" title="">LINK</a>
          
        </div>
      </div>
    </nav>
  </div>
</header><main id="content">
    

    <div class="single-container layout-block">
      <div class="article-info">
        <div class="article-header layout-padding">
          <div class="article-cover card-container content-padding-large soft-size--large soft-style--box img ">

  <div class="card-cover">
    
      <img src="https://note.strawbreey.com/cover/1.jpg" alt="/cover/1.jpg" />
    
  </div>

  <div class="card-text">
    <h1 class="card-text--title">Go Example</h1>
    
      <p class="card-text--row">2020-12-14 12:18</p>
      
      
      

      
      
    
  </div>

</div>
        </div>

        <div class="article-content">
          <div class="markdown-body content-padding-large soft-size--large soft-style--box">
            <h3 id="1-编译">1. 编译</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;hello world&#34;</span>)
}
</code></pre></div><p>要运行这个程序，将这些代码放到 hello-world.go 中并且使用 go run 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">go run hello-world.go
hello world
</code></pre></div><p>有时候我们想将我们的程序编译成二进制文件。我们可以通过 go build 命来达到目的。</p>
<pre><code>go build hello-world.go
ls
</code></pre><blockquote>
<p>hello-world.exe</p>
</blockquote>
<p>然后我们可以直接运行这个二进制文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ls
hello-world.exe	hello-world.go
./hello-world
</code></pre></div><h3 id="2-字符串">2. 字符串</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;go&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;lang&#34;</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;1+1 =&#34;</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;7.0/3.0 =&#34;</span>, <span style="color:#ae81ff">7.0</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3.0</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#66d9ef">true</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">false</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#66d9ef">true</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">false</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(!<span style="color:#66d9ef">true</span>)

    <span style="color:#75715e">// golang
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1+1 = 2
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 7.0/3.0 = 2.3333333333333335
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// fals
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="3-变量">3. 变量</h3>
<ol>
<li>var 声明 1 个或者多个变量。</li>
<li>你可以申明一次性声明多个变量。</li>
<li>Go 将自动推断已经初始化的变量类型。</li>
<li>声明变量且没有给出对应的初始值时，变量将会初始化为零值 。例如，一个 int 的零值是 0。</li>
<li>:= 语句是申明并初始化变量的简写，例如这个例子中的 var f string = &ldquo;short&rdquo;。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span> = <span style="color:#e6db74">&#34;initial&#34;</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> = <span style="color:#66d9ef">true</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">e</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;short&#34;</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>)

    <span style="color:#75715e">// initial
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1 2
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// short
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="4-常量">4. 常量</h3>
<ul>
<li>Go 支持字符、字符串、布尔和数值 常量 。</li>
<li>const 用于声明一个常量。</li>
<li>const 语句可以出现在任何 var 语句可以出现的地方</li>
<li>常数表达式可以执行任意精度的运算</li>
<li>数值型常量是没有确定的类型的，直到它们被给定了一个类型，比如说一次显示的类型转化</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;math&#34;</span>

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span> = <span style="color:#e6db74">&#34;constant&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">n</span> = <span style="color:#ae81ff">500000000</span>
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">d</span> = <span style="color:#ae81ff">3e20</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">n</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">d</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(int64(<span style="color:#a6e22e">d</span>))
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sin</span>(<span style="color:#a6e22e">n</span>))

    <span style="color:#75715e">// constant
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 6e+11
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 600000000000
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// -0.28470407323754404
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="5-for-循环">5. For 循环</h3>
<p>for 是 Go 中唯一的循环结构。这里有 for 循环的三个基本使用方式。</p>
<ul>
<li>单个循环条件</li>
<li>经典的初始化/条件/后续形式 for 循环</li>
<li>不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// `for` 是 Go 中唯一的循环结构。这里有 `for` 循环的三个基本使用方式。
</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">// 最常用的方式，带单个循环条件。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
	}

	<span style="color:#75715e">// 经典的初始化/条件/后续形式 `for` 循环。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">7</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">9</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">j</span>)
	}

	<span style="color:#75715e">// 不带条件的 `for` 循环将一直执行，直到在循环体内使用了 `break` 或者 `return` 来跳出循环。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;loop&#34;</span>)
		<span style="color:#66d9ef">break</span>
	}
}
	
<span style="color:#75715e">// $ go run for.go
</span><span style="color:#75715e">// 1
</span><span style="color:#75715e">// 2
</span><span style="color:#75715e">// 3
</span><span style="color:#75715e">// 7
</span><span style="color:#75715e">// 8
</span><span style="color:#75715e">// 9
</span><span style="color:#75715e">// loop
</span></code></pre></div><h3 id="6-ifelse-分支">6. if/else 分支</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// `if` 和 `else` 分支结构在 Go 中当然是直接了当的了。
</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 这里是一个基本的例子。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">7</span><span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;7 is even&#34;</span>)
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;7 is odd&#34;</span>)
    }

    <span style="color:#75715e">// 你可以不要 `else` 只用 `if` 语句。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">8</span><span style="color:#f92672">%</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;8 is divisible by 4&#34;</span>)
    }

    <span style="color:#75715e">// 在条件语句之前可以有一个语句；任何在这里声明的变量
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 都可以在所有的条件分支中使用。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">9</span>; <span style="color:#a6e22e">num</span> &lt; <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">num</span>, <span style="color:#e6db74">&#34;is negative&#34;</span>)
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">num</span> &lt; <span style="color:#ae81ff">10</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">num</span>, <span style="color:#e6db74">&#34;has 1 digit&#34;</span>)
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">num</span>, <span style="color:#e6db74">&#34;has multiple digits&#34;</span>)
    }
}

<span style="color:#75715e">// 注意，在 Go 中，你可以不适用圆括号，但是花括号是需
</span><span style="color:#75715e">// 要的。
</span><span style="color:#75715e"></span>
</code></pre></div><blockquote>
<p>Go 里没有三目运算符，所以即使你只需要基本的条件判断，你仍需要使用完整的 if 语句。</p>
</blockquote>
<h3 id="7-switch-分支结构">7. switch 分支结构</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// _switch_ ，方便的条件分支语句。
</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;time&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// 一个基本的 `switch`。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;write &#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#e6db74">&#34; as &#34;</span>)

	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;one&#34;</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;two&#34;</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;three&#34;</span>)
	}

	<span style="color:#75715e">// 在一个 `case` 语句中，你可以使用逗号来分隔多个表达式。在这个例子中，我们很好的使用了可选的`default` 分支。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() {
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Saturday</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sunday</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;it&#39;s the weekend&#34;</span>)
		<span style="color:#66d9ef">default</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;it&#39;s a weekday&#34;</span>)
	}

	<span style="color:#75715e">// 不带表达式的 `switch` 是实现 if/else 逻辑的另一种方式。这里展示了 `case` 表达式是如何使用非常量的。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#66d9ef">switch</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Hour</span>() &lt; <span style="color:#ae81ff">12</span>:
				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;it&#39;s before noon&#34;</span>)
		<span style="color:#66d9ef">default</span>:
				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;it&#39;s after noon&#34;</span>)
	}
}

<span style="color:#75715e">// todo: type switches
</span></code></pre></div><h3 id="8-数组">8. 数组</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 在 Go 中，_数组_ 是一个固定长度的数列。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 这里我们创建了一个数组 `a` 来存放刚好 5 个 `int`。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 元素的类型和长度都是数组类型的一部分。数组默认是
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 零值的，对于 `int` 数组来说也就是 `0`。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;emp:&#34;</span>, <span style="color:#a6e22e">a</span>)

    <span style="color:#75715e">// 我们可以使用 `array[index] = value` 语法来设置数组
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 指定位置的值，或者用 `array[index]` 得到值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">100</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;set:&#34;</span>, <span style="color:#a6e22e">a</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;get:&#34;</span>, <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">4</span>])

    <span style="color:#75715e">// 使用内置函数 `len` 返回数组的长度
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">a</span>))

    <span style="color:#75715e">// 使用这个语法在一行内初始化一个数组
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;dcl:&#34;</span>, <span style="color:#a6e22e">b</span>)

    <span style="color:#75715e">// 数组的存储类型是单一的，但是你可以组合这些数据
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 来构造多维的数据结构。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">twoD</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">twoD</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">j</span>
        }
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;2d: &#34;</span>, <span style="color:#a6e22e">twoD</span>)
}

</code></pre></div><h3 id="9-切片">9. 切片</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// _Slice_ 是 Go 中一个重要的数据类型，它提供了比数组更强大的序列交互方式。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 与数组不同，slice 的类型仅由它所包含的元素的类型决定（与元素个数无关）。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 要创建一个长度不为 0 的空 slice，需要使用内建函数 `make`。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里我们创建了一个长度为 3 的 `string` 类型的 slice（初始值为零值）。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">3</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;emp:&#34;</span>, <span style="color:#a6e22e">s</span>)

    <span style="color:#75715e">// 我们可以和数组一样设置和得到值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;a&#34;</span>
    <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#e6db74">&#34;b&#34;</span>
    <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;c&#34;</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;set:&#34;</span>, <span style="color:#a6e22e">s</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;get:&#34;</span>, <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>])

    <span style="color:#75715e">// `len` 返回 slice 的长度
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">s</span>))

    <span style="color:#75715e">// 除了基本操作外，slice 支持比数组更丰富的操作。比如 slice 支持内建函数 `append`，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 该函数会返回一个包含了一个或者多个新值的 slice。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注意由于 `append` 可能返回一个新的 slice，我们需要接收其返回值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;d&#34;</span>)
    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;e&#34;</span>, <span style="color:#e6db74">&#34;f&#34;</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;apd:&#34;</span>, <span style="color:#a6e22e">s</span>)

    <span style="color:#75715e">// slice 还可以 `copy`。这里我们创建一个空的和 `s` 有相同长度的 slice——`c`，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 然后将 `s` 复制给 `c`。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, len(<span style="color:#a6e22e">s</span>))
    copy(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">s</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;cpy:&#34;</span>, <span style="color:#a6e22e">c</span>)

    <span style="color:#75715e">// slice 支持通过 `slice[low:high]` 语法进行“切片”操作。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 例如，右边的操作可以得到一个包含元素 `s[2]`、`s[3]` 和 `s[4]` 的 slice。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">5</span>]
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sl1:&#34;</span>, <span style="color:#a6e22e">l</span>)

    <span style="color:#75715e">// 这个 slice 包含从 `s[0]` 到 `s[5]`（不包含 5）的元素。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">l</span> = <span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">5</span>]
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sl2:&#34;</span>, <span style="color:#a6e22e">l</span>)

    <span style="color:#75715e">// 这个 slice 包含从 `s[2]`（包含 2）之后的元素。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">l</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:]
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sl3:&#34;</span>, <span style="color:#a6e22e">l</span>)

    <span style="color:#75715e">// 我们可以在一行代码中声明并初始化一个 slice 变量。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;g&#34;</span>, <span style="color:#e6db74">&#34;h&#34;</span>, <span style="color:#e6db74">&#34;i&#34;</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;dcl:&#34;</span>, <span style="color:#a6e22e">t</span>)

    <span style="color:#75715e">// Slice 可以组成多维数据结构。内部的 slice 长度可以不一致，这一点和多维数组不同。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">twoD</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">innerLen</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#a6e22e">twoD</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">innerLen</span>)
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">innerLen</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">twoD</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">j</span>
        }
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;2d: &#34;</span>, <span style="color:#a6e22e">twoD</span>)
}
</code></pre></div><h3 id="10-map">10. Map</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// _map_ 是 Go 内建的[关联数据类型](http://zh.wikipedia.org/wiki/关联数组)
</span><span style="color:#75715e">// （在一些其他的语言中也被称为 _哈希(hash)_ 或者 _字典(dict)_ ）。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 要创建一个空 map，需要使用内建函数 `make`：`make(map[key-type]val-type)`。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)

    <span style="color:#75715e">// 使用典型的 `make[key] = val` 语法来设置键值对。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;k1&#34;</span>] = <span style="color:#ae81ff">7</span>
    <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;k2&#34;</span>] = <span style="color:#ae81ff">13</span>

    <span style="color:#75715e">// 打印 map。例如，使用 `fmt.Println` 打印一个 map，会输出它所有的键值对。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;map:&#34;</span>, <span style="color:#a6e22e">m</span>)

    <span style="color:#75715e">// 使用 `name[key]` 来获取一个键的值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;k1&#34;</span>]
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;v1: &#34;</span>, <span style="color:#a6e22e">v1</span>)

    <span style="color:#75715e">// 内建函数 `len` 可以返回一个 map 的键值对数量。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">m</span>))

    <span style="color:#75715e">// 内建函数 `delete` 可以从一个 map 中移除键值对。
</span><span style="color:#75715e"></span>    delete(<span style="color:#a6e22e">m</span>, <span style="color:#e6db74">&#34;k2&#34;</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;map:&#34;</span>, <span style="color:#a6e22e">m</span>)

    <span style="color:#75715e">// 当从一个 map 中取值时，还有可以选择是否接收的第二个返回值，该值表明了 map 中是否存在这个键。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这可以用来消除 `键不存在` 和 `键的值为零值` 产生的歧义，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 例如 `0` 和 `&#34;&#34;`。这里我们不需要值，所以用 _空白标识符(blank identifier)_ _ 将其忽略。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">prs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;k2&#34;</span>]
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;prs:&#34;</span>, <span style="color:#a6e22e">prs</span>)

    <span style="color:#75715e">// 你也可以通过右边的语法在一行代码中声明并初始化一个新的 map。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;foo&#34;</span>: <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;bar&#34;</span>: <span style="color:#ae81ff">2</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;map:&#34;</span>, <span style="color:#a6e22e">n</span>)
}

<span style="color:#75715e">// map: map[k1:7 k2:13]
</span><span style="color:#75715e">// v1:  7
</span><span style="color:#75715e">// len: 2
</span><span style="color:#75715e">// map: map[k1:7]
</span><span style="color:#75715e">// prs: false
</span><span style="color:#75715e">// map: map[bar:2 foo:1]
</span></code></pre></div><h3 id="11-range-遍历">11. Range 遍历</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// _range_ 用于迭代各种各样的数据结构。
</span><span style="color:#75715e">// 让我们来看看如何在我们已经学过的数据结构上使用 `range`。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 这里我们使用 `range` 来对 slice 中的元素求和。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 数组也可以用这种方法初始化并赋初值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">nums</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">num</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sum:&#34;</span>, <span style="color:#a6e22e">sum</span>)

    <span style="color:#75715e">// `range` 在数组和 slice 中提供对每项的索引和值的访问。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 上面我们不需要索引，所以我们使用 _空白标识符_ `_` 将其忽略。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 实际上，我们有时候是需要这个索引的。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;index:&#34;</span>, <span style="color:#a6e22e">i</span>)
        }
    }

    <span style="color:#75715e">// `range` 在 map 中迭代键值对。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">kvs</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;a&#34;</span>: <span style="color:#e6db74">&#34;apple&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>: <span style="color:#e6db74">&#34;banana&#34;</span>}
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">kvs</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s -&gt; %s\n&#34;</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
    }

    <span style="color:#75715e">// `range` 也可以只遍历 map 的键。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">kvs</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;key:&#34;</span>, <span style="color:#a6e22e">k</span>)
    }

    <span style="color:#75715e">// `range` 在字符串中迭代 unicode 码点(code point)。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 第一个返回值是字符的起始字节位置，然后第二个是字符本身。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#e6db74">&#34;go&#34;</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">c</span>)
    }
}


</code></pre></div><h3 id="12-函数">12. 函数</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// _函数_ 是 Go 的核心。我们将通过一些不同的例子来进行学习它。
</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 这里是一个函数，接受两个 `int` 并且以 `int` 返回它们的和
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">plus</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#75715e">// Go 需要明确的 return，也就是说，它不会自动 return 最后一个表达式的值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>
}

<span style="color:#75715e">// 当多个连续的参数为同样类型时，
</span><span style="color:#75715e">// 可以仅声明最后一个参数的类型，忽略之前相同类型参数的类型声明。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">plusPlus</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">c</span>
}

<span style="color:#75715e">// Go 原生支持 _多返回值_。
</span><span style="color:#75715e">// 这个特性在 Go 语言中经常用到，例如用来同时返回一个函数的结果和错误信息。
</span><span style="color:#75715e">// `(int, int)` 在这个函数中标志着这个函数返回 2 个 `int`。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">vals</span>() (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 通过 `函数名(参数列表)` 来调用函数，
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">plus</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;1+2 =&#34;</span>, <span style="color:#a6e22e">res</span>)

    <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">plusPlus</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;1+2+3 =&#34;</span>, <span style="color:#a6e22e">res</span>)

    <span style="color:#75715e">// 这里我们通过 _多赋值_ 操作来使用这两个不同的返回值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">vals</span>()
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)

    <span style="color:#75715e">// 如果你仅仅需要返回值的一部分的话，你可以使用空白标识符 `_`。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">vals</span>()
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>)
}

</code></pre></div><h3 id="13-多返回值">13. 多返回值</h3>
<h3 id="14-可变参数函数">14. 可变参数函数</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#75715e">// [_可变参数函数_](https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%8A%E5%8F%83%E6%95%B8%E5%87%BD%E6%95%B8)。
</span><span style="color:#75715e">// 在调用时可以传递任意数量的参数。
</span><span style="color:#75715e">// 例如，`fmt.Println` 就是一个常见的变参函数。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 这个函数接受任意数量的 `int` 作为参数。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">nums</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">nums</span>, <span style="color:#e6db74">&#34; &#34;</span>)
    <span style="color:#a6e22e">total</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
        <span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">num</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">total</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 变参函数使用常规的调用方式，传入独立的参数。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sum</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">sum</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)

    <span style="color:#75715e">// 如果你有一个含有多个值的 slice，想把它们作为参数使用，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 你需要这样调用 `func(slice...)`。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">nums</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}

    <span style="color:#75715e">// ...展开符
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">nums</span><span style="color:#f92672">...</span>)
}
</code></pre></div><h3 id="15-闭包">15. 闭包</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Go 支持[_匿名函数_](http://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0)，
</span><span style="color:#75715e">// 并能用其构造 &lt;a href=&#34;http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;&lt;em&gt;闭包&lt;/em&gt;&lt;/a&gt;。
</span><span style="color:#75715e">// 匿名函数在你想定义一个不需要命名的内联函数时是很实用的。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// `intSeq` 函数返回一个在其函数体内定义的匿名函数。
</span><span style="color:#75715e">// 返回的函数使用闭包的方式 _隐藏_ 变量 `i`。
</span><span style="color:#75715e">// 返回的函数 _隐藏_ 变量 `i` 以形成闭包。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">intSeq</span>() <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> {
        <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 我们调用 `intSeq` 函数，将返回值（一个函数）赋给 `nextInt`。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这个函数的值包含了自己的值 `i`，这样在每次调用 `nextInt` 时，都会更新 `i` 的值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">nextInt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">intSeq</span>()

    <span style="color:#75715e">// 通过多次调用 `nextInt` 来看看闭包的效果。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">nextInt</span>())
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">nextInt</span>())
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">nextInt</span>())

    <span style="color:#75715e">// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newInts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">intSeq</span>()
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">newInts</span>())
}

</code></pre></div><h3 id="16-递归">16. 递归</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Go 支持 &lt;a href=&#34;http://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;&lt;em&gt;递归&lt;/em&gt;&lt;/a&gt;。
</span><span style="color:#75715e">// 这里是一个经典的阶乘示例。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// `fact` 函数在到达 `fact(0)` 前一直调用自身。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fact</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">fact</span>(<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">fact</span>(<span style="color:#ae81ff">7</span>))
}

</code></pre></div><h3 id="17-指针">17. 指针</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Go 支持 &lt;em&gt;&lt;a href=&#34;http://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)&#34;&gt;指针&lt;/a&gt;&lt;/em&gt;，
</span><span style="color:#75715e">// 允许在程序中通过 `引用传递` 来传递值和数据结构。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 我们将通过两个函数：`zeroval` 和 `zeroptr` 来比较 `指针` 和 `值`。
</span><span style="color:#75715e">// `zeroval` 有一个 `int` 型参数，所以使用值传递。
</span><span style="color:#75715e">// `zeroval` 将从调用它的那个函数中得到一个实参的拷贝：ival。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">zeroval</span>(<span style="color:#a6e22e">ival</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">ival</span> = <span style="color:#ae81ff">0</span>
}

<span style="color:#75715e">// `zeroptr` 有一个和上面不同的参数：`*int`，这意味着它使用了 `int` 指针。
</span><span style="color:#75715e">// 紧接着，函数体内的 `*iptr` 会 _解引用_ 这个指针，从它的内存地址得到这个地址当前对应的值。
</span><span style="color:#75715e">// 对解引用的指针赋值，会改变这个指针引用的真实地址的值。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">zeroptr</span>(<span style="color:#a6e22e">iptr</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) {
    <span style="color:#f92672">*</span><span style="color:#a6e22e">iptr</span> = <span style="color:#ae81ff">0</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;initial:&#34;</span>, <span style="color:#a6e22e">i</span>)

    <span style="color:#a6e22e">zeroval</span>(<span style="color:#a6e22e">i</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;zeroval:&#34;</span>, <span style="color:#a6e22e">i</span>)

    <span style="color:#75715e">// 通过 `&amp;i` 语法来取得 `i` 的内存地址，即指向 `i` 的指针。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">zeroptr</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;zeroptr:&#34;</span>, <span style="color:#a6e22e">i</span>)

    <span style="color:#75715e">// 指针也是可以被打印的。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;pointer:&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>)
}

<span style="color:#75715e">// initial: 1
</span><span style="color:#75715e">// zeroval: 1
</span><span style="color:#75715e">// zeroptr: 0
</span><span style="color:#75715e">// pointer: 0xc00002c008
</span></code></pre></div><h3 id="17-结构体">17. 结构体</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Go 的_结构体(struct)_ 是带类型的字段(fields)集合。
</span><span style="color:#75715e">// 这在组织数据时非常有用。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 这里的 `person` 结构体包含了 `name` 和 `age` 两个字段。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">person</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">age</span>  <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 使用这个语法创建新的结构体元素。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">person</span>{<span style="color:#e6db74">&#34;Bob&#34;</span>, <span style="color:#ae81ff">20</span>})

    <span style="color:#75715e">// 你可以在初始化一个结构体元素时指定字段名字。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">person</span>{<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">30</span>})

    <span style="color:#75715e">// 省略的字段将被初始化为零值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">person</span>{<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;Fred&#34;</span>})

    <span style="color:#75715e">// `&amp;` 前缀生成一个结构体指针。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">person</span>{<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;Ann&#34;</span>, <span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">40</span>})

    <span style="color:#75715e">// 使用`.`来访问结构体字段。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">person</span>{<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;Sean&#34;</span>, <span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">50</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">name</span>)

    <span style="color:#75715e">// 也可以对结构体指针使用`.` - 指针会被自动解引用。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sp</span>.<span style="color:#a6e22e">age</span>)

    <span style="color:#75715e">// 结构体是可变(mutable)的。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sp</span>.<span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">51</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sp</span>.<span style="color:#a6e22e">age</span>)
}

</code></pre></div><h3 id="18-方法">18. 方法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Go 支持为结构体类型定义_方法(methods)_ 。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">rect</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">// 这里的 `area` 是一个拥有 `*rect` 类型接收器(receiver)的方法。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rect</span>) <span style="color:#a6e22e">area</span>() <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">height</span>
}

<span style="color:#75715e">// 可以为值类型或者指针类型的接收者定义方法。
</span><span style="color:#75715e">// 这是一个值类型接收者的例子。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rect</span>) <span style="color:#a6e22e">perim</span>() <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">height</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rect</span>{<span style="color:#a6e22e">width</span>: <span style="color:#ae81ff">10</span>, <span style="color:#a6e22e">height</span>: <span style="color:#ae81ff">5</span>}

    <span style="color:#75715e">// 这里我们调用上面为结构体定义的两个方法。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;area: &#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">area</span>())
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;perim:&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">perim</span>())

    <span style="color:#75715e">// 调用方法时，Go 会自动处理值和指针之间的转换。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 想要避免在调用方法时产生一个拷贝，或者想让方法可以修改接受结构体的值，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 你都可以使用指针来调用方法。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">rp</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">r</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;area: &#34;</span>, <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">area</span>())
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;perim:&#34;</span>, <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">perim</span>())
}
</code></pre></div><h3 id="19-接口">19. 接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 方法签名的集合叫做：_接口(Interfaces)_。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#75715e">// 这是一个几何体的基本接口。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">geometry</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">area</span>() <span style="color:#66d9ef">float64</span>
    <span style="color:#a6e22e">perim</span>() <span style="color:#66d9ef">float64</span>
}

<span style="color:#75715e">// 在这个例子中，我们将为 `rect` 和 `circle` 实现该接口。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">rect</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span> <span style="color:#66d9ef">float64</span>
}
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">circle</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">radius</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#75715e">// 要在 Go 中实现一个接口，我们只需要实现接口中的所有方法。
</span><span style="color:#75715e">// 这里我们为 `rect` 实现了 `geometry` 接口。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rect</span>) <span style="color:#a6e22e">area</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">height</span>
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rect</span>) <span style="color:#a6e22e">perim</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">height</span>
}

<span style="color:#75715e">// `circle` 的实现。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">circle</span>) <span style="color:#a6e22e">area</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">radius</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">radius</span>
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">circle</span>) <span style="color:#a6e22e">perim</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">radius</span>
}

<span style="color:#75715e">// 如果一个变量实现了某个接口，我们就可以调用指定接口中的方法。
</span><span style="color:#75715e">// 这儿有一个通用的 `measure` 函数，我们可以通过它来使用所有的 `geometry`。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">measure</span>(<span style="color:#a6e22e">g</span> <span style="color:#a6e22e">geometry</span>) {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">g</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">area</span>())
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">perim</span>())
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rect</span>{<span style="color:#a6e22e">width</span>: <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">height</span>: <span style="color:#ae81ff">4</span>}
    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">circle</span>{<span style="color:#a6e22e">radius</span>: <span style="color:#ae81ff">5</span>}

    <span style="color:#75715e">// 结构体类型 `circle` 和 `rect` 都实现了 `geometry` 接口，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 所以我们可以将其实例作为 `measure` 的参数。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">measure</span>(<span style="color:#a6e22e">r</span>)
    <span style="color:#a6e22e">measure</span>(<span style="color:#a6e22e">c</span>)
}

</code></pre></div><h3 id="21-错误处理">21. 错误处理</h3>
<p>符合 Go 语言习惯的做法是使用一个独立、明确的返回值来传递错误信息。 这与 Java、Ruby 使用的异常（exception） 以及在 C 语言中有时用到的重载 (overloaded) 的单返回/错误值有着明显的不同。 Go 语言的处理方式能清楚的知道哪个函数返回了错误，并使用跟其他（无异常处理的）语言类似的方式来处理错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> ( <span style="color:#e6db74">&#34;errors&#34;</span> <span style="color:#e6db74">&#34;fmt&#34;</span> )


<span style="color:#75715e">// 按照惯例，错误通常是最后一个返回值并且是 error 类型，它是一个内建的接口。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">arg</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arg</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">42</span> {
        <span style="color:#75715e">// errors.New 使用给定的错误信息构造一个基本的 error 值。 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;can&#39;t work with 42&#34;</span>)
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arg</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">nil</span>
}


<span style="color:#75715e">// 你还可以通过实现 Error() 方法来自定义 error 类型。 这里使用自定义错误类型来表示上面例子中的参数错误。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">argError</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">arg</span>  <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">prob</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#75715e">// 你还可以通过实现 Error() 方法来自定义 error 类型。 这里使用自定义错误类型来表示上面例子中的参数错误
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">argError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d - %s&#34;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">arg</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">prob</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f2</span>(<span style="color:#a6e22e">arg</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arg</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">42</span> {

        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">argError</span>{<span style="color:#a6e22e">arg</span>, <span style="color:#e6db74">&#34;can&#39;t work with it&#34;</span>}
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arg</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">42</span>} {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">i</span>); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;f1 failed:&#34;</span>, <span style="color:#a6e22e">e</span>)
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;f1 worked:&#34;</span>, <span style="color:#a6e22e">r</span>)
        }
    }
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">42</span>} {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f2</span>(<span style="color:#a6e22e">i</span>); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;f2 failed:&#34;</span>, <span style="color:#a6e22e">e</span>)
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;f2 worked:&#34;</span>, <span style="color:#a6e22e">r</span>)
        }
    }

    <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f2</span>(<span style="color:#ae81ff">42</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ae</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">argError</span>); <span style="color:#a6e22e">ok</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ae</span>.<span style="color:#a6e22e">arg</span>)
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ae</span>.<span style="color:#a6e22e">prob</span>)
    }
}
</code></pre></div><h3 id="22-协程">22. 协程</h3>
<p>协程(goroutine) 是轻量级的执行线程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)


<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">from</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">from</span>, <span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#a6e22e">i</span>)
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 假设我们有一个函数叫做 f(s)。 我们一般会这样 同步地 调用它
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#34;direct&#34;</span>)

    <span style="color:#75715e">// 使用 go f(s) 在一个协程中调用这个函数。 这个新的 Go 协程将会 并发地 执行这个函数。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#34;goroutine&#34;</span>)

    <span style="color:#75715e">// 你也可以为匿名函数启动一个协程。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">msg</span> <span style="color:#66d9ef">string</span>) {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">msg</span>)
    }(<span style="color:#e6db74">&#34;going&#34;</span>)

    <span style="color:#75715e">// 现在两个协程在独立的协程中 异步地 运行， 然后等待两个协程完成（更好的方法是使用 WaitGroup）。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;done&#34;</span>)
}

</code></pre></div><p>direct : 0
direct : 1
direct : 2
goroutine : 0
going
goroutine : 1
goroutine : 2
done</p>
<h3 id="23-通道">23. 通道</h3>
<p>通道(channels) 是连接多个协程的管道。 你可以从一个协程将值发送到通道，然后在另一个协程中接收。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 使用 make(chan val-type) 创建一个新的通道。 通道类型就是他们需要传递值的类型。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">messages</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)

    <span style="color:#75715e">// 使用 channel &lt;- 语法 发送 一个新的值到通道中。 这里我们在一个新的协程中发送 &#34;ping&#34; 到上面创建的 messages 通道中。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">messages</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;ping&#34;</span> }()

    <span style="color:#75715e">// 使用 &lt;-channel 语法从通道中 接收 一个值。 这里我们会收到在上面发送的 &#34;ping&#34; 消息并将其打印出来。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">messages</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">msg</span>)
    <span style="color:#75715e">// 我们运行程序时，通过通道， 成功的将消息 &#34;ping&#34; 从一个协程传送到了另一个协程中。
</span><span style="color:#75715e"></span>}
</code></pre></div><p>$ go run channels.go
ping</p>
<p>默认发送和接收操作是阻塞的，直到发送方和接收方都就绪。 这个特性允许我们，不使用任何其它的同步操作， 就可以在程序结尾处等待消息 &ldquo;ping&rdquo;。</p>
<h3 id="24-通道缓冲">24. 通道缓冲</h3>
<p>默认情况下，通道是 无缓冲 的，这意味着只有对应的接收（&lt;- chan） 通道准备好接收时，才允许进行发送（chan &lt;-）。 有缓冲通道 允许在没有对应接收者的情况下，缓存一定数量的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#a6e22e">messages</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">2</span>)

    <span style="color:#a6e22e">messages</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;buffered&#34;</span>
    <span style="color:#a6e22e">messages</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;channel&#34;</span>

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">messages</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">messages</span>)
}
</code></pre></div><h3 id="25-通道同步">25. 通道同步</h3>
<p>可以使用通道来同步协程之间的执行状态。 这儿有一个例子，使用阻塞接收的方式，实现了等待另一个协程完成。 如果需要等待多个协程，WaitGroup 是一个更好的选择。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">

<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)
<span style="color:#75715e">//  我们将要在协程中运行这个函数。 done 通道将被用于通知其他协程这个函数已经完成工作。
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">done</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>) {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;working...&#34;</span>)
    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;done&#34;</span>)
    
    <span style="color:#75715e">// 发送一个值来通知我们已经完工啦。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">true</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 运行一个 worker 协程，并给予用于通知的通道。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>, <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">done</span>)
    <span style="color:#75715e">// 程序将一直阻塞，直至收到 worker 使用通道发送的通知。
</span><span style="color:#75715e"></span>    <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
}

</code></pre></div><h3 id="26-通道方向">26. 通道方向</h3>
<p>当使用通道作为函数的参数时，你可以指定这个通道是否为只读或只写。 该特性可以提升程序的类型安全。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// ping 函数定义了一个只能发送数据的（只写）通道。 尝试从这个通道接收数据会是一个编译时错误。
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ping</span>(<span style="color:#a6e22e">pings</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">msg</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#a6e22e">pings</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">msg</span>
}

<span style="color:#75715e">// pong 函数接收两个通道，pings 仅用于接收数据（只读），pongs 仅用于发送数据（只写）。
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pong</span>(<span style="color:#a6e22e">pings</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">pongs</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">pings</span>
    <span style="color:#a6e22e">pongs</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">msg</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">pings</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">1</span>)
    <span style="color:#a6e22e">pongs</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">1</span>)
    <span style="color:#a6e22e">ping</span>(<span style="color:#a6e22e">pings</span>, <span style="color:#e6db74">&#34;passed message&#34;</span>)
    <span style="color:#a6e22e">pong</span>(<span style="color:#a6e22e">pings</span>, <span style="color:#a6e22e">pongs</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">pongs</span>)
}
<span style="color:#960050;background-color:#1e0010">$</span> <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">run</span> <span style="color:#a6e22e">channel</span><span style="color:#f92672">-</span><span style="color:#a6e22e">directions</span>.<span style="color:#66d9ef">go</span>
</code></pre></div><h3 id="27-通过选择器">27. 通过选择器</h3>
<p>Go 的 选择器（select） 让你可以同时等待多个通道操作。 将协程、通道和选择器结合，是 Go 的一个强大特性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 在这个例子中，我们将从两个通道中选择。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">c1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
    <span style="color:#a6e22e">c2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)

    <span style="color:#75715e">// 各个通道将在一定时间后接收一个值， 通过这种方式来模拟并行的协程执行（例如，RPC 操作）时造成的阻塞（耗时）。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
        <span style="color:#a6e22e">c1</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;one&#34;</span>
    }()
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
        <span style="color:#a6e22e">c2</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;two&#34;</span>
    }()
    
    <span style="color:#75715e">// 我们使用 select 关键字来同时等待这两个值， 并打印各自接收到的值。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">msg1</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c1</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;received&#34;</span>, <span style="color:#a6e22e">msg1</span>)
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">msg2</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c2</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;received&#34;</span>, <span style="color:#a6e22e">msg2</span>)
        }
    }
}

</code></pre></div><p>// 跟预期的一样，我们首先接收到值 &ldquo;one&rdquo;，然后是 &ldquo;two&rdquo;。</p>
<p>$ time go run select.go
received one
received two
注意，程序总共仅运行了两秒左右。因为 1 秒 和 2 秒的 Sleeps 是并发执行的，</p>
<p>real    0m2.245s</p>
<h3 id="28-超时处理">28. 超时处理</h3>
<p>超时 对于一个需要连接外部资源， 或者有耗时较长的操作的程序而言是很重要的。 得益于通道和 select，在 Go 中实现超时操作是简洁而优雅的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> ( <span style="color:#e6db74">&#34;fmt&#34;</span> <span style="color:#e6db74">&#34;time&#34;</span>)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#75715e">// 在这个例子中，假如我们执行一个外部调用， 并在 2 秒后使用通道 c1 返回它的执行结果。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">c1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
        <span style="color:#a6e22e">c1</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;result 1&#34;</span>
    }()
    
    <span style="color:#75715e">// 这里是使用 select 实现一个超时操作。 res := &lt;- c1 等待结果，&lt;-Time.After 等待超时（1秒钟）以后发送的值。 由于 select 默认处理第一个已准备好的接收操作， 因此如果操作耗时超过了允许的 1 秒的话，将会执行超时 case。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c1</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">res</span>)
        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>):
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;timeout 1&#34;</span>)
    }
    <span style="color:#75715e">// 如果我们允许一个长一点的超时时间：3 秒， 就可以成功的从 c2 接收到值，并且打印出结果。
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">c2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
        <span style="color:#a6e22e">c2</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;result 2&#34;</span>
    }()

    <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c2</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">res</span>)
        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>):
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;timeout 2&#34;</span>)
    }
}
</code></pre></div><p>运行这个程序，首先显示运行超时的操作，然后是成功接收的。</p>
<p>$ go run timeouts.go
timeout 1
result 2</p>
<h3 id="29-非阻塞通道操作">29. 非阻塞通道操作</h3>
<p>常规的通过通道发送和接收数据是阻塞的。 然而，我们可以使用带一个 default 子句的 select 来实现 非阻塞 的发送、接收，甚至是非阻塞的多路 select。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">messages</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
    <span style="color:#a6e22e">signals</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
    
    <span style="color:#75715e">// 这是一个非阻塞接收的例子。 如果在 messages 中存在，然后 select 将这个值带入 &lt;-messages case 中。 否则，就直接到 default 分支中。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">messages</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;received message&#34;</span>, <span style="color:#a6e22e">msg</span>)
        <span style="color:#66d9ef">default</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;no message received&#34;</span>)
    }
    
    <span style="color:#75715e">// 一个非阻塞发送的例子，代码结构和上面接收的类似。 msg 不能被发送到 message 通道，因为这是 个无缓冲区通道，并且也没有接收者，因此， default 会执行。
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;hi&#34;</span>
    <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">messages</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">msg</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sent message&#34;</span>, <span style="color:#a6e22e">msg</span>)
        <span style="color:#66d9ef">default</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;no message sent&#34;</span>)
    }
    <span style="color:#75715e">// 我们可以在 default 前使用多个 case 子句来实现一个多路的非阻塞的选择器。 这里我们试图在 messages 和 signals 上同时使用非阻塞的接收操作。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">messages</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;received message&#34;</span>, <span style="color:#a6e22e">msg</span>)
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">sig</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">signals</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;received signal&#34;</span>, <span style="color:#a6e22e">sig</span>)
        <span style="color:#66d9ef">default</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;no activity&#34;</span>)
    }
}
</code></pre></div><p>$ go run non-blocking-channel-operations.go
no message received
no message sent
no activity</p>
<h3 id="30-通道的关闭">30. 通道的关闭</h3>
<p>关闭 一个通道意味着不能再向这个通道发送值了。 该特性可以向通道的接收方传达工作已经完成的信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 在这个例子中，我们将使用一个 jobs 通道，将工作内容， 从 main() 协程传递到一个工作协程中。 当我们没有更多的任务传递给工作协程时，我们将 close 这个 jobs 通道。
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">jobs</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)
    <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
    
    <span style="color:#75715e">// 这是工作协程。使用 j, more := &lt;- jobs 循环的从 jobs 接收数据。 根据接收的第二个值，如果 jobs 已经关闭了， 并且通道中所有的值都已经接收完毕，那么 more 的值将是 false。 当我们完成所有的任务时，会使用这个特性通过 done 通道通知 main 协程。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#66d9ef">for</span> {
            <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">more</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">jobs</span>
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">more</span> {
                <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;received job&#34;</span>, <span style="color:#a6e22e">j</span>)
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;received all jobs&#34;</span>)
                <span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">true</span>
                <span style="color:#66d9ef">return</span>
            }
        }
    }()
    <span style="color:#75715e">// 使用 jobs 发送 3 个任务到工作协程中，然后关闭 jobs。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">jobs</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">j</span>
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sent job&#34;</span>, <span style="color:#a6e22e">j</span>)
    }
    close(<span style="color:#a6e22e">jobs</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sent all jobs&#34;</span>)
    <span style="color:#75715e">// 使用前面学到的通道同步方法等待任务结束。
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
}
</code></pre></div><p>$ go run closing-channels.go
sent job 1
received job 1
sent job 2
received job 2
sent job 3
received job 3
sent all jobs
received all jobs
根据 关闭通道 的思想，可以引出我们的下一个示例：遍历通道。</p>
<h3 id="31-通道遍历">31. 通道遍历</h3>
<p>在前面的例子中， 我们讲过 for 和 range 为基本的数据结构提供了迭代的功能。 我们也可以使用这个语法来遍历的从通道中取值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 我们将遍历在 queue 通道中的两个值。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">queue</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;one&#34;</span>
    <span style="color:#a6e22e">queue</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;two&#34;</span>
    close(<span style="color:#a6e22e">queue</span>)
    
    <span style="color:#75715e">// range 迭代从 queue 中得到每个值。 因为我们在前面 close 了这个通道，所以，这个迭代会在接收完 2 个值之后结束。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">elem</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">queue</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">elem</span>)
    }
}
</code></pre></div><p>这个例子也让我们看到，一个非空的通道也是可以关闭的， 并且，通道中剩下的值仍然可以被接收到。</p>
<p>$ go run range-over-channels.go
one
two</p>
<h3 id="32-timer">32. Timer</h3>
<p>我们经常需要在未来的某个时间点运行 Go 代码，或者每隔一定时间重复运行代码。 Go 内置的 定时器 和 打点器 特性让这些变得很简单。 我们会先学习定时器，然后再学习打点器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 定时器表示在未来某一时刻的独立事件。 你告诉定时器需要等待的时间，然后它将提供一个用于通知的通道。 这里的定时器将等待 2 秒。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">timer1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTimer</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
    <span style="color:#75715e">// &lt;-timer1.C 会一直阻塞， 直到定时器的通道 C 明确的发送了定时器失效的值。
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">timer1</span>.<span style="color:#a6e22e">C</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Timer 1 fired&#34;</span>)

    <span style="color:#75715e">// 如果你需要的仅仅是单纯的等待，使用 time.Sleep 就够了。 使用定时器的原因之一就是，你可以在定时器触发之前将其取消。 例如这样。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">timer2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTimer</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)

    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">timer2</span>.<span style="color:#a6e22e">C</span>
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Timer 2 fired&#34;</span>)
    }()

    <span style="color:#a6e22e">stop2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">timer2</span>.<span style="color:#a6e22e">Stop</span>()

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">stop2</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Timer 2 stopped&#34;</span>)
    }

    <span style="color:#75715e">// 给 timer2 足够的时间来触发它，以证明它实际上已经停止了。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
}
</code></pre></div><p>第一个定时器将在程序开始后大约 2s 触发， 但是第二个定时器还未触发就停止了。</p>
<p>$ go run timers.go
Timer 1 fired
Timer 2 stopped</p>
<h3 id="33-ticker">33. Ticker</h3>
<p>定时器 是当你想要在未来某一刻执行一次时使用的 - 打点器 则是为你想要以固定的时间间隔重复执行而准备的。 这里是一个打点器的例子，它将定时的执行，直到我们将它停止。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 打点器和定时器的机制有点相似：使用一个通道来发送数据。 这里我们使用通道内建的 select，等待每 500ms 到达一次的值。
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">ticker</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTicker</span>(<span style="color:#ae81ff">500</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// ticker 等同于 setinterval, 每500ms 触发一次  
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#66d9ef">for</span> {
            <span style="color:#66d9ef">select</span> {
            <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>:
                <span style="color:#66d9ef">return</span>
            <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">C</span>:
                <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Tick at&#34;</span>, <span style="color:#a6e22e">t</span>)
            }
        }
    }()
    
    <span style="color:#75715e">// 打点器可以和定时器一样被停止。 打点器一旦停止，将不能再从它的通道中接收到值。 我们将在运行 1600ms 后停止这个打点器。
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1600</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
    <span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">Stop</span>()
    <span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">true</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Ticker stopped&#34;</span>)
}

</code></pre></div><p>当我们运行这个程序时，打点器会在我们停止它前打点 3 次。</p>
<p>$ go run tickers.go
Tick at 2012-09-23 11:29:56.487625 -0700 PDT
Tick at 2012-09-23 11:29:56.988063 -0700 PDT
Tick at 2012-09-23 11:29:57.488076 -0700 PDT
Ticker stopped</p>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="https://gobyexample.com/" target="_blank" rel="noopener">Go by Example</a></li>
<li><a href="https://gobyexample-cn.github.io/" target="_blank" rel="noopener">Go by Example 中文版</a></li>
<li><a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">error-handling-and-go</a></li>
</ul>

          </div>
        </div>
                 
      
  
  
  
  

  

  <div class="article-paging">
    
      <section class="post-paging--item card-container content-padding-primary soft-size--primary soft-style--box">
  <div class="card-cover" ></div>
  <div class="card-text">
    <a href="/posts/202012142337/"><h4 class="card-text--title text-ellipsis">Js For</h4></a>
    <p class="card-text--row">2020-12-14 23:37</p>
  </div>
</section>
    
    
      <section class="post-paging--item card-container content-padding-primary soft-size--primary soft-style--box">
  <div class="card-cover" ></div>
  <div class="card-text">
    <a href="/posts/202012141129/"><h4 class="card-text--title text-ellipsis">Go Import</h4></a>
    <p class="card-text--row">2020-12-14 11:29</p>
  </div>
</section>
    
  </div>
</div>
  <aside class="widget-info">
    
<section class="aside-widget widget-author content-padding-large soft-size--large soft-style--box">
  <div class="widget-body">
    <div class="author-box avatar">
      
      <img class="author-avatar soft-size--round soft-style--box" src="https://s.gravatar.com/avatar/7b5a0b07a98895278cfa862b1f32ae8f?s=200&amp;r=g&amp;d=retro" alt="Sukoshi">
      
      <h2 class="author-name text-ellipsis">Sukoshi</h2>
      
      <p class="author-desc text-ellipsis">梅花鹿的角叫鹿角</p>
      
    </div>
  </div>
</section>


    


    










<section class="aside-widget widget-articles content-padding-large soft-size--large soft-style--box">
  <h2 class="widget-header">
    <div class="title">
      <span>Related Posts</span>
    </div>
  </h2>
  <div class="widget-body">
    <ul class="post-list">
      
      
        <li class="post-item"><a href="/posts/202107261428/">Gin Start</a></li>
      
        <li class="post-item"><a href="/posts/202108061612/">Php Implode</a></li>
      
        <li class="post-item"><a href="/posts/202108061510/">Sql Query Null</a></li>
      
        <li class="post-item"><a href="/posts/202108061125/">Elk</a></li>
      
        <li class="post-item"><a href="/posts/202108051754/">Git Worktree Prune</a></li>
      
        <li class="post-item"><a href="/posts/202108051727/">Go Tour</a></li>
      
    </ul>
  </div>
</section>


    




<section class="aside-widget widget-categories content-padding-large soft-size--large soft-style--box">
  <h2 class="widget-header">
    <div class="title">
      <span>Categories</span>
    </div>
  </h2>
  <div class="widget-body">
    <ul class="categories-list">
      
        <li>
          <a href="https://note.strawbreey.com/categories/go/">GO</a>
          <span>2</span>
        </li>
      
    </ul>
  </div>

  
</section>


    




<section class="aside-widget widget-tags content-padding-large soft-size--large soft-style--box">
  <h2 class="widget-header">
    <div class="title">
      <span>Tags</span>
    </div>
  </h2>
  <div class="widget-body">
    <div class="tags-list">
      
        <a href="https://note.strawbreey.com/tags/php/" data-count="23" class="soft-size--small soft-style--hover soft-style--active">php</a>
      
        <a href="https://note.strawbreey.com/tags/leetcode/" data-count="14" class="soft-size--small soft-style--hover soft-style--active">leetcode</a>
      
        <a href="https://note.strawbreey.com/tags/vscode/" data-count="3" class="soft-size--small soft-style--hover soft-style--active">vscode</a>
      
        <a href="https://note.strawbreey.com/tags/git/" data-count="2" class="soft-size--small soft-style--hover soft-style--active">git</a>
      
        <a href="https://note.strawbreey.com/tags/mysql/" data-count="2" class="soft-size--small soft-style--hover soft-style--active">mysql</a>
      
        <a href="https://note.strawbreey.com/tags/webapi/" data-count="2" class="soft-size--small soft-style--hover soft-style--active">webApi</a>
      
        <a href="https://note.strawbreey.com/tags/angular/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">angular</a>
      
        <a href="https://note.strawbreey.com/tags/devops/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">devops</a>
      
        <a href="https://note.strawbreey.com/tags/go/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">GO</a>
      
        <a href="https://note.strawbreey.com/tags/interview/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">interview</a>
      
        <a href="https://note.strawbreey.com/tags/toggle/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">toggle</a>
      
    </div>
  </div>

  
</section>

  </aside>
</div>
  </main><footer class="footer-container layout-block">
  
  <div class="social-icons">
    
      <a class="soft-size--primary soft-style--box" href="https://github.com/miiiku" target="_blank" rel="noopener noreferrer">
          
        <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
        </svg>
        

        

        

        

        
      </a>
    
      <a class="soft-size--primary soft-style--box" href="https://twitter.com/guanquanhong" target="_blank" rel="noopener noreferrer">
        

          
        <svg class="icon icon-twitter" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <path d="M962.285714 233.142857q-38.285714 56-92.571429 95.428571 0.571429 8 0.571429 24 0 74.285714-21.714286 148.285714t-66 142-105.428571 120.285714-147.428571 83.428571-184.571429 31.142857q-154.857143 0-283.428571-82.857143 20 2.285714 44.571429 2.285714 128.571429 0 229.142857-78.857143-60-1.142857-107.428571-36.857143t-65.142857-91.142857q18.857143 2.857143 34.857143 2.857143 24.571429 0 48.571429-6.285714-64-13.142857-106-63.714286t-42-117.428571l0-2.285714q38.857143 21.714286 83.428571 23.428571-37.714286-25.142857-60-65.714286t-22.285714-88q0-50.285714 25.142857-93.142857 69.142857 85.142857 168.285714 136.285714t212.285714 56.857143q-4.571429-21.714286-4.571429-42.285714 0-76.571429 54-130.571429t130.571429-54q80 0 134.857143 58.285714 62.285714-12 117.142857-44.571429-21.142857 65.714286-81.142857 101.714286 53.142857-5.714286 106.285714-28.571429z"></path>
        </svg>
        

        

        

        
      </a>
    
      <a class="soft-size--primary soft-style--box" href="https://www.instagram.com/sukoshi_dayo/" target="_blank" rel="noopener noreferrer">
        

        

          
        <svg class="icon icon-instagram" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <path d="M512 0C372.906667 0 355.541333 0.64 300.928 3.072 246.4 5.632 209.28 14.208 176.64 26.88c-33.664 13.056-62.250667 30.592-90.709333 59.050667S39.893333 142.933333 26.88 176.64C14.208 209.28 5.589333 246.4 3.072 300.928 0.512 355.541333 0 372.906667 0 512s0.64 156.458667 3.072 211.072c2.56 54.485333 11.136 91.648 23.808 124.288a251.093333 251.093333 0 0 0 59.050667 90.709333A250.368 250.368 0 0 0 176.64 997.12c32.682667 12.629333 69.802667 21.290667 124.288 23.808C355.541333 1023.488 372.906667 1024 512 1024s156.458667-0.64 211.072-3.072c54.485333-2.56 91.648-11.178667 124.288-23.808a251.648 251.648 0 0 0 90.709333-59.050667 250.026667 250.026667 0 0 0 59.050667-90.709333c12.629333-32.64 21.290667-69.802667 23.808-124.288 2.56-54.613333 3.072-71.978667 3.072-211.072s-0.64-156.458667-3.072-211.072c-2.56-54.485333-11.178667-91.690667-23.808-124.288a251.306667 251.306667 0 0 0-59.050667-90.709333A249.472 249.472 0 0 0 847.36 26.88c-32.64-12.672-69.802667-21.290667-124.288-23.808C668.458667 0.512 651.093333 0 512 0z m0 92.16c136.661333 0 152.96 0.682667 206.933333 3.029333 49.92 2.346667 77.013333 10.624 95.018667 17.706667 23.978667 9.258667 40.96 20.352 58.965333 38.229333 17.877333 17.92 28.970667 34.944 38.229334 58.922667 6.997333 18.005333 15.36 45.098667 17.621333 95.018667 2.432 54.016 2.986667 70.229333 2.986667 206.933333s-0.64 152.96-3.157334 206.933333c-2.602667 49.92-10.922667 77.013333-17.962666 95.018667a162.56 162.56 0 0 1-38.357334 58.965333 159.744 159.744 0 0 1-58.88 38.229334c-17.92 6.997333-45.44 15.36-95.36 17.621333-54.357333 2.432-70.357333 2.986667-207.317333 2.986667-137.002667 0-153.002667-0.64-207.317333-3.157334-49.962667-2.602667-77.482667-10.922667-95.402667-17.962666a158.549333 158.549333 0 0 1-58.837333-38.357334 155.477333 155.477333 0 0 1-38.4-58.88c-7.04-17.92-15.317333-45.44-17.92-95.36-1.92-53.76-2.602667-70.357333-2.602667-206.677333 0-136.362667 0.682667-153.002667 2.602667-207.402667 2.602667-49.92 10.88-77.397333 17.92-95.317333 8.96-24.32 20.437333-40.96 38.4-58.922667 17.877333-17.877333 34.56-29.397333 58.837333-38.314666 17.92-7.082667 44.842667-15.402667 94.762667-17.962667 54.4-1.92 70.4-2.56 207.317333-2.56l1.92 1.28z m0 156.928a262.912 262.912 0 1 0 0 525.824 262.912 262.912 0 1 0 0-525.824zM512 682.666667c-94.293333 0-170.666667-76.373333-170.666667-170.666667s76.373333-170.666667 170.666667-170.666667 170.666667 76.373333 170.666667 170.666667-76.373333 170.666667-170.666667 170.666667z m334.762667-443.946667a61.482667 61.482667 0 0 1-122.88 0 61.44 61.44 0 0 1 122.88 0z"></path>
        </svg>
        

        

        
      </a>
    
      <a class="soft-size--primary soft-style--box" href="https://weibo.com/u/5561168966" target="_blank" rel="noopener noreferrer">
        

        

        

          
        <svg class="icon icon-weibo" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <path d="M385.682429 733.696q11.995429-19.456 6.290286-39.424t-25.746286-28.598857q-19.456-7.972571-41.691429-0.585143t-34.304 26.258286q-12.580571 19.456-7.460571 39.131429t24.576 28.891429 42.569143 1.462857 35.693714-27.136zM439.442429 664.576q4.534857-7.460571 1.974857-15.140571t-10.020571-10.605714q-7.972571-2.852571-16.310857 0.292571t-12.288 10.605714q-9.728 17.700571 7.460571 25.746286 7.972571 2.852571 16.603429-0.292571t12.580571-10.605714zM538.843572 725.723429q-25.746286 58.294857-90.258286 85.723429t-128 6.875429q-61.147429-19.456-84.260571-72.265143t3.730286-107.154286q26.843429-53.174857 86.601143-79.433143t120.32-10.825143q63.414857 16.603429 90.550857 68.315429t1.462857 108.836571zM717.165858 634.294857q-5.12-54.857143-50.834286-97.133714t-119.149714-62.317714-156.891429-11.995429q-127.414857 13.165714-211.163429 80.822857t-75.702857 151.113143q5.12 54.857143 50.834286 97.133714t119.149714 62.317714 156.891429 11.995429q127.414857-13.165714 211.163429-80.822857t75.702857-151.113143zM893.147572 636.562286q0 38.838857-21.138286 79.725714t-62.317714 78.262857-96.256 67.145143-129.170286 47.396571-154.550857 17.700571-157.110857-19.163429-137.435429-53.174857-98.011429-86.308571-37.156571-114.029714q0-65.682286 39.716571-139.995429t112.859429-147.456q96.548571-96.548571 195.145143-134.875429t140.873143 4.022857q37.156571 36.571429 11.410286 119.442286-2.267429 7.972571-0.585143 11.410286t5.705143 4.022857 8.265143-0.292571 7.68-1.974857l3.437714-1.170286q79.433143-33.718857 140.580571-33.718857t87.405714 34.889143q25.746286 35.986286 0 101.741714-1.170286 7.460571-2.56 11.410286t2.56 7.168 6.875429 4.315429 9.728 3.437714q32.548571 10.313143 58.88 26.843429t45.714286 46.592 19.456 66.56zM850.871001 279.990857q23.990857 26.843429 31.158857 62.025143t-3.730286 67.145143q-4.534857 13.165714-16.822857 19.456t-25.453714 2.267429q-13.165714-4.534857-19.456-16.822857t-2.267429-25.453714q11.410286-35.986286-13.677714-63.414857t-61.147429-19.968q-13.677714 2.852571-25.746286-4.534857t-14.262857-21.138286q-2.852571-13.677714 4.534857-25.453714t21.138286-14.555429q34.304-7.460571 68.022857 3.145143t57.709714 37.449143zM954.295001 186.88q49.737143 54.857143 64.292571 127.122286t-7.68 138.020571q-5.12 15.433143-19.456 22.820571t-29.696 2.267429-22.820571-19.456-2.852571-29.696q16.018286-46.884571 5.705143-98.304t-45.714286-90.258286q-35.401143-39.424-84.553143-54.564571t-98.889143-4.827429q-16.018286 3.437714-29.696-5.412571t-17.115429-24.868571 5.412571-29.403429 24.868571-16.822857q70.290286-14.848 139.410286 6.582857t118.857143 76.873143z"></path>
        </svg>
        

        
      </a>
    
      <a class="soft-size--primary soft-style--box" href="https://www.zhihu.com/people/miku-84" target="_blank" rel="noopener noreferrer">
        

        

        

        

          
        <svg class="icon icon-zhihu" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <path d="M544.949 561.422s0-71.387-34.779-75.050c-34.779-3.663-142.775 0-142.775 0v-219.654h161.078s-1.83-73.219-32.949-73.219h-261.755l43.93-117.148s-65.897 3.663-89.692 45.761-98.844 252.604-98.844 252.604 25.627 10.983 67.726-20.134c42.101-31.116 56.743-86.033 56.743-86.033l76.879-3.663 1.83 223.316s-133.621-1.83-161.078 0c-27.457 1.83-42.101 75.050-42.101 75.050h203.182s-18.307 124.47-69.557 214.164c-53.085 89.692-151.929 161.078-151.929 161.078s71.387 29.287 140.947-10.983c69.557-42.101 120.811-223.316 120.811-223.316l162.912 203.182s14.643-97.013-1.83-124.47c-18.307-27.457-113.49-137.283-113.49-137.283l-42.101 36.607 29.287-120.811h177.552zM587.050 188.010l-1.83 660.793h65.897l23.795 82.37 115.321-82.37h162.912v-660.793h-366.091zM879.92 775.584h-76.879l-97.013 75.050-21.965-75.050h-20.134v-512.527h215.991v512.527z"></path>
        </svg>
        
      </a>
    
  </div>
  

  <div class="colour-bar"></div>
  
  
  <p>© 2021 <a href="https://github.com/miiiku/hugo-theme-kagome">kagome</a>.</p>
  

  

  <p>
    Powered by
    <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a>
    Theme - 
    <a href="https://github.com/miiiku/hugo-theme-kagome" target="_blank" rel="noopener noreferrer author">kagome</a>
  </p>

  <p>
    <a href="javascript:;" id="theme-light">🌞 light</a>
    <a href="javascript:;" id="theme-dark">🌛 dark</a>
    <a href="javascript:;" id="theme-auto">🤖️ auto</a>
  </p>
</footer>







</body>

</html>
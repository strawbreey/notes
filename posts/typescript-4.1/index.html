<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Typescript 4 ::
        Strawbreey Notes
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="Template Literal Types String literal types in TypeScript allow us to model functions and APIs that expect a set of specific strings. function setVerticalAlignment(color: &amp;#34;top&amp;#34; | &amp;#34;middle&amp;#34; | &amp;#34;bottom&amp;#34;) { // ... } setVerticalAlignment(&amp;#34;middel&amp;#34;); // Argument of type &amp;#39;&amp;#34;middel&amp;#34;&amp;#39; is not assignable to parameter of type &amp;#39;&amp;#34;top&amp;#34; | &amp;#34;middle&amp;#34; | &amp;#34;bottom&amp;#34;&amp;#39;. This is pretty nice because string literal types can basically spell-check our string values. We also like that string"
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/typescript-4.1/" />





<link rel="stylesheet" href="/assets/style.css" />

<link rel="stylesheet" href="/style.css" />


<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/styles/atom-one-dark.min.css">

<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="/favicon.png" />





<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Typescript 4"/>
<meta name="twitter:description" content="Template Literal Types String literal types in TypeScript allow us to model functions and APIs that expect a set of specific strings. function setVerticalAlignment(color: &#34;top&#34; | &#34;middle&#34; | &#34;bottom&#34;) { // ... } setVerticalAlignment(&#34;middel&#34;); // Argument of type &#39;&#34;middel&#34;&#39; is not assignable to parameter of type &#39;&#34;top&#34; | &#34;middle&#34; | &#34;bottom&#34;&#39;. This is pretty nice because string literal types can basically spell-check our string values. We also like that string"/>



<meta property="og:title" content="Typescript 4" />
<meta property="og:description" content="Template Literal Types String literal types in TypeScript allow us to model functions and APIs that expect a set of specific strings. function setVerticalAlignment(color: &#34;top&#34; | &#34;middle&#34; | &#34;bottom&#34;) { // ... } setVerticalAlignment(&#34;middel&#34;); // Argument of type &#39;&#34;middel&#34;&#39; is not assignable to parameter of type &#39;&#34;top&#34; | &#34;middle&#34; | &#34;bottom&#34;&#39;. This is pretty nice because string literal types can basically spell-check our string values. We also like that string" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/typescript-4.1/" />
<meta property="article:published_time" content="2020-12-07T22:59:26+08:00" />
<meta property="article:modified_time" content="2020-12-07T22:59:26+08:00" /><meta property="og:site_name" content="Strawbreey Notes" />






  </head>
  <body class="">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    
    <span class="logo__text">
      Strawbreey Notes
    </span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/showcase">Showcase</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Typescript 4</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2020-12-07
        </span>

        
          
        
      

      


      
    </div>

    

    

    <div class="post-content">
      
      <h3 id="template-literal-types">Template Literal Types</h3>
<p>String literal types in TypeScript allow us to model functions and APIs that expect a set of specific strings.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setVerticalAlignment</span>(<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;top&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;middle&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;bottom&#34;</span>) {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}

<span style="color:#a6e22e">setVerticalAlignment</span>(<span style="color:#e6db74">&#34;middel&#34;</span>);
<span style="color:#75715e">// Argument of type &#39;&#34;middel&#34;&#39; is not assignable to parameter of type &#39;&#34;top&#34; | &#34;middle&#34; | &#34;bottom&#34;&#39;.
</span><span style="color:#75715e"></span>
</code></pre></div><p>This is pretty nice because string literal types can basically spell-check our string values.</p>
<p>We also like that string literals can be used as property names in mapped types. In this sense, they’re also usable as building blocks:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Options</span> <span style="color:#f92672">=</span> {
  [<span style="color:#a6e22e">K</span> <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;noImplicitAny&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;strictNullChecks&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;strictFunctionTypes&#34;</span>]<span style="color:#f92672">?:</span> <span style="color:#66d9ef">boolean</span>;
};
<span style="color:#75715e">// same as
</span><span style="color:#75715e">//   type Options = {
</span><span style="color:#75715e">//       noImplicitAny?: boolean,
</span><span style="color:#75715e">//       strictNullChecks?: boolean,
</span><span style="color:#75715e">//       strictFunctionTypes?: boolean
</span><span style="color:#75715e">//   };
</span></code></pre></div><p>But there’s another place that that string literal types could be used as building blocks: building other string literal types.</p>
<p>That’s why TypeScript 4.1 brings the template literal string type. It has the same syntax as template literal strings in JavaScript, but is used in type positions. When you use it with concrete literal types, it produces a new string literal type by concatenating the contents.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">World</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;world&#34;</span>;

<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Greeting</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`hello </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">World</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
<span style="color:#75715e">//   ^ = type Greeting = &#34;hello world&#34;
</span></code></pre></div><p>What happens when you have unions in substitution positions? It produces the set of every possible string literal that could be represented by each union member.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Color</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;red&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;blue&#34;</span>;
<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Quantity</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;two&#34;</span>;

<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">SeussFish</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">Quantity</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Color</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> fish`</span>;
<span style="color:#75715e">//   ^ = type SeussFish = &#34;one fish&#34; | &#34;two fish&#34; | &#34;red fish&#34; | &#34;blue fish&#34;
</span></code></pre></div><p>This can be used beyond cute examples in release notes. For example, several libraries for UI components have a way to specify both vertical and horizontal alignment in their APIs, often with both at once using a single string like &ldquo;bottom-right&rdquo;. Between vertically aligning with &ldquo;top&rdquo;, &ldquo;middle&rdquo;, and &ldquo;bottom&rdquo;, and horizontally aligning with &ldquo;left&rdquo;, &ldquo;center&rdquo;, and &ldquo;right&rdquo;, there are 9 possible strings where each of the former strings is connected with each of the latter strings using a dash.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">VerticalAlignment</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;top&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;middle&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;bottom&#34;</span>;
<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">HorizontalAlignment</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;left&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;center&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;right&#34;</span>;

<span style="color:#75715e">// Takes
</span><span style="color:#75715e">//   | &#34;top-left&#34;    | &#34;top-center&#34;    | &#34;top-right&#34;
</span><span style="color:#75715e">//   | &#34;middle-left&#34; | &#34;middle-center&#34; | &#34;middle-right&#34;
</span><span style="color:#75715e">//   | &#34;bottom-left&#34; | &#34;bottom-center&#34; | &#34;bottom-right&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setAlignment</span>(<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">VerticalAlignment</span><span style="color:#e6db74">}</span><span style="color:#e6db74">-</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">HorizontalAlignment</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;

<span style="color:#a6e22e">setAlignment</span>(<span style="color:#e6db74">&#34;top-left&#34;</span>);   <span style="color:#75715e">// works!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">setAlignment</span>(<span style="color:#e6db74">&#34;top-middel&#34;</span>); <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">setAlignment</span>(<span style="color:#e6db74">&#34;top-pot&#34;</span>);  <span style="color:#75715e">// error! 
</span></code></pre></div><p>While there are lots of examples of this sort of API in the wild, this is still a bit of a toy example since we could write these out manually. In fact, for 9 strings, this is likely fine; but when you need a ton of strings, you should consider automatically generating them ahead of time to save work on every type-check (or just use string, which will be much simpler to comprehend).</p>
<p>Some of the real value comes from dynamically creating new string literals. For example, imagine a makeWatchedObject API that takes an object and produces a mostly identical object, but with a new on method to detect for changes to the properties.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">makeWatchedObject</span>({
  <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Homer&#34;</span>,
  <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">42</span>, <span style="color:#75715e">// give-or-take
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">location</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Springfield&#34;</span>,
});

<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#34;firstNameChanged&#34;</span>, () <span style="color:#f92672">=&gt;</span> {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`firstName was changed!`</span>);
});
</code></pre></div><p>Notice that on listens on the event &ldquo;firstNameChanged&rdquo;, not just &ldquo;firstName&rdquo;. How would we type this?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">PropEventSource</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">on</span>(<span style="color:#a6e22e">eventName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">string</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span><span style="color:#e6db74">}</span><span style="color:#e6db74">Changed`</span>, <span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
};

<span style="color:#75715e">/// Create a &#34;watched object&#34; with an &#39;on&#39; method
</span><span style="color:#75715e">/// so that you can watch for changes to properties.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makeWatchedObject</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">obj</span>: <span style="color:#66d9ef">T</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">PropEventSource</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>;
</code></pre></div><p>With this, we can build something that errors when we give the wrong property!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#75715e">// error!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#34;firstName&#34;</span>, () <span style="color:#f92672">=&gt;</span> {});
<span style="color:#75715e">// Argument of type &#39;&#34;firstName&#34;&#39; is not assignable to parameter of type &#39;&#34;firstNameChanged&#34; | &#34;ageChanged&#34; | &#34;locationChanged&#34;&#39;.
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// error!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#34;frstNameChanged&#34;</span>, () <span style="color:#f92672">=&gt;</span> {});
<span style="color:#75715e">// Argument of type &#39;&#34;frstNameChanged&#34;&#39; is not assignable to parameter of type &#39;&#34;firstNameChanged&#34; | &#34;ageChanged&#34; | &#34;locationChanged&#34;&#39;.
</span></code></pre></div><p>We can also do something special in template literal types: we can infer from substitution positions. We can make our last example generic to infer from parts of the eventName string to figure out the associated property.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">PropEventSource</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">on</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">K</span> <span style="color:#66d9ef">extends</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
        (<span style="color:#a6e22e">eventName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">K</span><span style="color:#e6db74">}</span><span style="color:#e6db74">Changed`</span>, <span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">newValue</span>: <span style="color:#66d9ef">T</span>[<span style="color:#a6e22e">K</span>]) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span> )<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
};

<span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makeWatchedObject</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">obj</span>: <span style="color:#66d9ef">T</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">PropEventSource</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>;

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">makeWatchedObject</span>({
    <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Homer&#34;</span>,
    <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">42</span>,
    <span style="color:#a6e22e">location</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Springfield&#34;</span>,
});

<span style="color:#75715e">// works! &#39;newName&#39; is typed as &#39;string&#39;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#34;firstNameChanged&#34;</span>, <span style="color:#a6e22e">newName</span> <span style="color:#f92672">=&gt;</span> {
    <span style="color:#75715e">// &#39;newName&#39; has the type of &#39;firstName&#39;
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`new name is </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">newName</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
});

<span style="color:#75715e">// works! &#39;newAge&#39; is typed as &#39;number&#39;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#34;ageChanged&#34;</span>, <span style="color:#a6e22e">newAge</span> <span style="color:#f92672">=&gt;</span> {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">newAge</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;warning! negative age&#34;</span>);
    }
})
</code></pre></div><p>Here we made on into a generic method. When a user calls with the string &ldquo;firstNameChanged&rsquo;, TypeScript will try to infer the right type for K. To do that, it will match K against the content prior to &ldquo;Changed&rdquo; and infer the string &ldquo;firstName&rdquo;. Once TypeScript figures that out, the on method can fetch the type of firstName on the original object, which is string in this case. Similarly, when we call with &ldquo;ageChanged&rdquo;, it finds the type for the property age which is number).</p>
<p>Inference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways. In fact, to help with modifying these string literal types, we’ve added a few new utility type aliases for modifying casing in letters (i.e. converting to lowercase and uppercase characters).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">EnthusiasticGreeting</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span> <span style="color:#66d9ef">extends</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">Uppercase</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>

<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">HELLO</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">EnthusiasticGreeting</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">&gt;</span>;
<span style="color:#75715e">//   ^ = type HELLO = &#34;HELLO&#34;s
</span></code></pre></div><p>The new type aliases are Uppercase, Lowercase, Capitalize and Uncapitalize. The first two transform every character in a string, and the latter two transform only the first character in a string.</p>
<p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/40336">see the original pull request</a> and <a href="https://github.com/microsoft/TypeScript/pull/40580">the in-progress pull request to switch to type alias helpers</a>.</p>
<h3 id="key-remapping-in-mapped-types">Key Remapping in Mapped Types</h3>
<p>Just as a refresher, a mapped type can create new object types based on arbitrary keys</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Options</span> <span style="color:#f92672">=</span> {
  [<span style="color:#a6e22e">K</span> <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;noImplicitAny&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;strictNullChecks&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;strictFunctionTypes&#34;</span>]<span style="color:#f92672">?:</span> <span style="color:#66d9ef">boolean</span>;
};
<span style="color:#75715e">// same as
</span><span style="color:#75715e">//   type Options = {
</span><span style="color:#75715e">//       noImplicitAny?: boolean,
</span><span style="color:#75715e">//       strictNullChecks?: boolean,
</span><span style="color:#75715e">//       strictFunctionTypes?: boolean
</span><span style="color:#75715e">//   };
</span></code></pre></div><p>or new object types based on other object types.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#75715e">/// &#39;Partial&lt;T&gt;&#39; is the same as &#39;T&#39;, but with each property marked optional.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Partial</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> {
  [<span style="color:#a6e22e">K</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span>]<span style="color:#f92672">?:</span> <span style="color:#a6e22e">T</span>[<span style="color:#a6e22e">K</span>];
};
</code></pre></div><p>Until now, mapped types could only produce new object types with keys that you provided them; however, lots of the time you want to be able to create new keys, or filter out keys, based on the inputs.</p>
<p>That’s why TypeScript 4.1 allows you to re-map keys in mapped types with a new as clause.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">MappedTypeWithNewKeys</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> {
    [<span style="color:#a6e22e">K</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">NewKeyType</span>]<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span>[<span style="color:#a6e22e">K</span>]
    <span style="color:#75715e">//            ^^^^^^^^^^^^^
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//            This is the new syntax!
</span><span style="color:#75715e"></span>}
</code></pre></div><p>With this new as clause, you can leverage features like template literal types to easily create property names based off of old ones.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Getters</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> {
    [<span style="color:#a6e22e">K</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">as</span> <span style="color:#e6db74">`get</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">Capitalize</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">string</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">K</span><span style="color:#f92672">&gt;</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>]<span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">T</span>[<span style="color:#a6e22e">K</span>]
};

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Person</span> {
    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
    <span style="color:#a6e22e">age</span>: <span style="color:#66d9ef">number</span>;
    <span style="color:#a6e22e">location</span>: <span style="color:#66d9ef">string</span>;
}

<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">LazyPerson</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Getters</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Person</span><span style="color:#f92672">&gt;</span>;
<span style="color:#75715e">//   ^ = type LazyPerson = {
</span><span style="color:#75715e">//       getName: () =&gt; string;
</span><span style="color:#75715e">//       getAge: () =&gt; number;
</span><span style="color:#75715e">//       getLocation: () =&gt; string;
</span><span style="color:#75715e">//   }
</span></code></pre></div><p>and you can even filter out keys by producing never. That means you don’t have to use an extra Omit helper type in some cases.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#75715e">// Remove the &#39;kind&#39; property
</span><span style="color:#75715e"></span><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">RemoveKindField</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> {
    [<span style="color:#a6e22e">K</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">Exclude</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">K</span>, <span style="color:#e6db74">&#34;kind&#34;</span><span style="color:#f92672">&gt;</span>]<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span>[<span style="color:#a6e22e">K</span>]
};

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Circle</span> {
    <span style="color:#a6e22e">kind</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;circle&#34;</span>;
    <span style="color:#a6e22e">radius</span>: <span style="color:#66d9ef">number</span>;
}

<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">KindlessCircle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">RemoveKindField</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Circle</span><span style="color:#f92672">&gt;</span>;
<span style="color:#75715e">//   ^ = type KindlessCircle = {
</span><span style="color:#75715e">//       radius: number;
</span><span style="color:#75715e">//   }
</span></code></pre></div><p>For more information, take a look at <a href="https://github.com/microsoft/TypeScript/pull/40336">the original pull request over on GitHub</a>.</p>
<h3 id="recursive-递归-conditional-types">Recursive (递归) Conditional Types</h3>
<p>In JavaScript it’s fairly common to see functions that can flatten and build up container types at arbitrary levels. For example, consider the .then() method on instances of Promise. .then(&hellip;) unwraps each promise until it finds a value that’s not “promise-like”, and passes that value to a callback. There’s also a relatively new flat method on Arrays that can take a depth of how deep to flatten.</p>
<p>Expressing this in TypeScript’s type system was, for all practical intents and purposes, not possible. While there were hacks to achieve this, the types ended up looking very unreasonable.</p>
<p>That’s why TypeScript 4.1 eases some restrictions on conditional types - so that they can model these patterns. In TypeScript 4.1, conditional types can now immediately reference themselves within their branches, making it easier to write recursive type aliases.</p>
<p>For example, if we wanted to write a type to get the element types of nested arrays, we could write the following deepFlatten type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">ElementType</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">ReadonlyArray</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">infer</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">ElementType</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span>;

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">deepFlatten</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">readonly</span> <span style="color:#a6e22e">unknown</span>[]<span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">T</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">ElementType</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>[] {
  <span style="color:#66d9ef">throw</span> <span style="color:#e6db74">&#34;not implemented&#34;</span>;
}

<span style="color:#75715e">// All of these return the type &#39;number[]&#39;:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">deepFlatten</span>([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]);
<span style="color:#a6e22e">deepFlatten</span>([[<span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]]);
<span style="color:#a6e22e">deepFlatten</span>([[<span style="color:#ae81ff">1</span>], [[<span style="color:#ae81ff">2</span>]], [[[<span style="color:#ae81ff">3</span>]]]]);
</code></pre></div><p>[todo]
<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types</a></p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
              <span class="button previous">
                <a href="/posts/silicon-valley-5-1/">
                  <span class="button__icon">←</span>
                  <span class="button__text">Silicon Valley 5 1</span>
                </a>
              </span>
            
            
              <span class="button next">
                <a href="/posts/grpc-go/">
                  <span class="button__text">Grpc Go</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Copyright©2019-2020 Strawbreey. All Rights Reserved</div>
      
  </div>
</footer>

<script src="/assets/main.js"></script>

<script src="/assets/mermaid.min.js"></script>


<script>hljs.initHighlightingOnLoad();</script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/highlight.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>


      
    </div>

    
  </body>
</html>

<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Js Storage - My New Hugo Site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="olOwOlo" /><meta name="description" content="LocalStorage，sessionStorage Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。
它们有趣的是，在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。我们很快就会看到。
我们已经有了 cookie。为什么还要其他存储对象呢？
与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数浏览器都允许保存至少 2MB 的数据（或更多），并且具有用于配置数据的设置。 还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。 存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。 两个存储对象都提供相同的方法和属性：
 setItem(key, value) —— 存储键/值对。 getItem(key) —— 按照键获取值。 removeItem(key) —— 删除键及其对应的值。 clear() —— 删除所有数据。 key(index) —— 获取该索引下的键名。 length —— 存储的内容的长度。  正如你所看到的，它就像一个 Map 集合（setItem/getItem/removeItem），但也允许通过 key(index) 来按索引访问。
localStorage 示例 localStorage 最主要的特点是：
 在同源的所有标签页和窗口之间共享数据。 数据不会过期。它在浏览器重启甚至系统重启后仍然存在。  localStorage.setItem(&amp;#39;test&amp;#39;, 1); // 然后关闭/重新打开浏览器，或者只是在不同的窗口打开同一页面，然后你可以这样获取它：  alert( localStorage.getItem(&amp;#39;test&amp;#39;) ); // 1 // 我们只需要在同一个源（域/端口/协议），URL 路径可以不同。 在所有同源的窗口之间，localStorage 数据可以共享。因此，如果我们在一个窗口中设置了数据，则在另一个窗口中也可以看到数据变化。" />






<meta name="generator" content="Hugo 0.86.0-DEV with theme even" />


<link rel="canonical" href="https://example.org/posts/js/js-storage/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">



<meta property="og:title" content="Js Storage" />
<meta property="og:description" content="LocalStorage，sessionStorage Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。
它们有趣的是，在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。我们很快就会看到。
我们已经有了 cookie。为什么还要其他存储对象呢？
与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数浏览器都允许保存至少 2MB 的数据（或更多），并且具有用于配置数据的设置。 还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。 存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。 两个存储对象都提供相同的方法和属性：
 setItem(key, value) —— 存储键/值对。 getItem(key) —— 按照键获取值。 removeItem(key) —— 删除键及其对应的值。 clear() —— 删除所有数据。 key(index) —— 获取该索引下的键名。 length —— 存储的内容的长度。  正如你所看到的，它就像一个 Map 集合（setItem/getItem/removeItem），但也允许通过 key(index) 来按索引访问。
localStorage 示例 localStorage 最主要的特点是：
 在同源的所有标签页和窗口之间共享数据。 数据不会过期。它在浏览器重启甚至系统重启后仍然存在。  localStorage.setItem(&#39;test&#39;, 1); // 然后关闭/重新打开浏览器，或者只是在不同的窗口打开同一页面，然后你可以这样获取它：  alert( localStorage.getItem(&#39;test&#39;) ); // 1 // 我们只需要在同一个源（域/端口/协议），URL 路径可以不同。 在所有同源的窗口之间，localStorage 数据可以共享。因此，如果我们在一个窗口中设置了数据，则在另一个窗口中也可以看到数据变化。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.org/posts/js/js-storage/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-24T17:06:47+08:00" />
<meta property="article:modified_time" content="2020-12-24T17:06:47+08:00" />

<meta itemprop="name" content="Js Storage">
<meta itemprop="description" content="LocalStorage，sessionStorage Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。
它们有趣的是，在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。我们很快就会看到。
我们已经有了 cookie。为什么还要其他存储对象呢？
与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数浏览器都允许保存至少 2MB 的数据（或更多），并且具有用于配置数据的设置。 还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。 存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。 两个存储对象都提供相同的方法和属性：
 setItem(key, value) —— 存储键/值对。 getItem(key) —— 按照键获取值。 removeItem(key) —— 删除键及其对应的值。 clear() —— 删除所有数据。 key(index) —— 获取该索引下的键名。 length —— 存储的内容的长度。  正如你所看到的，它就像一个 Map 集合（setItem/getItem/removeItem），但也允许通过 key(index) 来按索引访问。
localStorage 示例 localStorage 最主要的特点是：
 在同源的所有标签页和窗口之间共享数据。 数据不会过期。它在浏览器重启甚至系统重启后仍然存在。  localStorage.setItem(&#39;test&#39;, 1); // 然后关闭/重新打开浏览器，或者只是在不同的窗口打开同一页面，然后你可以这样获取它：  alert( localStorage.getItem(&#39;test&#39;) ); // 1 // 我们只需要在同一个源（域/端口/协议），URL 路径可以不同。 在所有同源的窗口之间，localStorage 数据可以共享。因此，如果我们在一个窗口中设置了数据，则在另一个窗口中也可以看到数据变化。"><meta itemprop="datePublished" content="2020-12-24T17:06:47+08:00" />
<meta itemprop="dateModified" content="2020-12-24T17:06:47+08:00" />
<meta itemprop="wordCount" content="437">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Js Storage"/>
<meta name="twitter:description" content="LocalStorage，sessionStorage Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。
它们有趣的是，在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。我们很快就会看到。
我们已经有了 cookie。为什么还要其他存储对象呢？
与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数浏览器都允许保存至少 2MB 的数据（或更多），并且具有用于配置数据的设置。 还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。 存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。 两个存储对象都提供相同的方法和属性：
 setItem(key, value) —— 存储键/值对。 getItem(key) —— 按照键获取值。 removeItem(key) —— 删除键及其对应的值。 clear() —— 删除所有数据。 key(index) —— 获取该索引下的键名。 length —— 存储的内容的长度。  正如你所看到的，它就像一个 Map 集合（setItem/getItem/removeItem），但也允许通过 key(index) 来按索引访问。
localStorage 示例 localStorage 最主要的特点是：
 在同源的所有标签页和窗口之间共享数据。 数据不会过期。它在浏览器重启甚至系统重启后仍然存在。  localStorage.setItem(&#39;test&#39;, 1); // 然后关闭/重新打开浏览器，或者只是在不同的窗口打开同一页面，然后你可以这样获取它：  alert( localStorage.getItem(&#39;test&#39;) ); // 1 // 我们只需要在同一个源（域/端口/协议），URL 路径可以不同。 在所有同源的窗口之间，localStorage 数据可以共享。因此，如果我们在一个窗口中设置了数据，则在另一个窗口中也可以看到数据变化。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">My New Hugo Site</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">My New Hugo Site</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <h2 id="localstoragesessionstorage">LocalStorage，sessionStorage</h2>
<p>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。</p>
<p>它们有趣的是，在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。我们很快就会看到。</p>
<p>我们已经有了 cookie。为什么还要其他存储对象呢？</p>
<p>与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数浏览器都允许保存至少 2MB 的数据（或更多），并且具有用于配置数据的设置。
还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。
存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。
两个存储对象都提供相同的方法和属性：</p>
<ul>
<li>setItem(key, value) —— 存储键/值对。</li>
<li>getItem(key) —— 按照键获取值。</li>
<li>removeItem(key) —— 删除键及其对应的值。</li>
<li>clear() —— 删除所有数据。</li>
<li>key(index) —— 获取该索引下的键名。</li>
<li>length —— 存储的内容的长度。</li>
</ul>
<p>正如你所看到的，它就像一个 Map 集合（setItem/getItem/removeItem），但也允许通过 key(index) 来按索引访问。</p>
<h3 id="localstorage-示例">localStorage 示例</h3>
<p>localStorage 最主要的特点是：</p>
<ul>
<li>在同源的所有标签页和窗口之间共享数据。</li>
<li>数据不会过期。它在浏览器重启甚至系统重启后仍然存在。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#39;test&#39;</span>, <span style="color:#ae81ff">1</span>);
<span style="color:#75715e">// 然后关闭/重新打开浏览器，或者只是在不同的窗口打开同一页面，然后你可以这样获取它：
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#e6db74">&#39;test&#39;</span>) ); <span style="color:#75715e">// 1
</span><span style="color:#75715e">// 我们只需要在同一个源（域/端口/协议），URL 路径可以不同。
</span></code></pre></div><p>在所有同源的窗口之间，localStorage 数据可以共享。因此，如果我们在一个窗口中设置了数据，则在另一个窗口中也可以看到数据变化。</p>
<p>类对象形式访问
我们还可以像使用一个普通对象那样，读取/设置键，像这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 设置 key
</span><span style="color:#75715e"></span><span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">test</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#75715e">// 获取 key
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">test</span> ); <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 删除 key
</span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">test</span>;
</code></pre></div><p>这是历史原因造成的，并且大多数情况下都可行，但通常不建议这样做，因为：</p>
<p>如果键是由用户生成的，那么它可以是任何内容，例如 length 或 toString，也可以是 localStorage 的另一种内建方法。在这种情况下，getItem/setItem 可以正常工作，而类对象访问的方式则会失败：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;length&#39;</span>;
<span style="color:#a6e22e">localStorage</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">// Error，无法对 length 进行赋值
</span></code></pre></div><p>有一个 storage 事件，在我们更改数据时会触发。但以类对象方式访问时，不会触发该事件。我们将在本章的后面看到。</p>
<h4 id="遍历键">遍历键</h4>
<p>正如我们所看到的，这些方法提供了“按照键获取/设置/删除”的功能。但我们如何获取所有保存的值或键呢？</p>
<p>不幸的是，存储对象是不可迭代的。</p>
<p>一种方法是像遍历数组那样遍历它们：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">key</span>(<span style="color:#a6e22e">i</span>);
  <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#a6e22e">key</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
}
</code></pre></div><p>另一个方式是使用 for key in localStorage 循环，就像处理常规对象一样。</p>
<p>它会遍历所有的键，但也会输出一些我们不需要的内建字段。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 不好的尝试
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">localStorage</span>) {
  <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">key</span>); <span style="color:#75715e">// 显示 getItem，setItem 和其他内建的东西
</span><span style="color:#75715e"></span>}
</code></pre></div><p>因此，我们需要使用 hasOwnProperty 检查来过滤掉原型中的字段：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">localStorage</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#a6e22e">key</span>)) {
    <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 跳过像 &#34;setItem&#34;，&#34;getItem&#34; 等这样的键
</span><span style="color:#75715e"></span>  }
  <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#a6e22e">key</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
}
</code></pre></div><p>或者，使用 Object.keys 获取只属于“自己”的键，然后如果需要，可以遍历它们：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">keys</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">localStorage</span>);
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">keys</span>) {
  <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#a6e22e">key</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
}
</code></pre></div><p>后者有效，因为 Object.keys 只返回属于对象的键，会忽略原型上的。</p>
<h4 id="仅字符串">仅字符串</h4>
<p>请注意，键和值都必须是字符串。</p>
<p>如果是任何其他类型，例数字或对象，它会被自动转换为字符串。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span>};
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">user</span>); <span style="color:#75715e">// [object Object]
</span></code></pre></div><p>我们可以使用 JSON 来存储对象：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>({<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span>});

<span style="color:#75715e">// sometime later
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>( <span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">user</span> );
<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span> ); <span style="color:#75715e">// John
</span><span style="color:#75715e"></span>
</code></pre></div><p>也可以对整个存储对象进行字符串化处理，例如出于调试目的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 为 JSON.stringify 增加了格式设置选项，以使对象看起来更美观
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>(<span style="color:#a6e22e">localStorage</span>, <span style="color:#66d9ef">null</span>, <span style="color:#ae81ff">2</span>) );
</code></pre></div><h3 id="sessionstorage">sessionStorage</h3>
<p>sessionStorage 对象的使用频率比 localStorage 对象低得多。</p>
<p>属性和方法是相同的，但是它有更多的限制：</p>
<p>sessionStorage 的数据只存在于当前浏览器标签页。</p>
<p>具有相同页面的另一个标签页中将会有不同的存储。
但是，它在同一标签页下的 iframe 之间是共享的（假如它们来自相同的源）。
数据在页面刷新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留。
让我们看看它的运行效果。</p>
<p>运行此代码……</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#39;test&#39;</span>, <span style="color:#ae81ff">1</span>);
<span style="color:#75715e">// ……然后刷新页面。这时你仍然可以获取到数据：
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#e6db74">&#39;test&#39;</span>) ); <span style="color:#75715e">// after refresh: 1
</span><span style="color:#75715e">// ……但是，如果你在另一个新的标签页中打开此页面，然后在新页面中再次运行上面这行代码，则会得到 null，表示“未找到数据”。
</span></code></pre></div><p>这是因为 sessionStorage 不仅绑定到源，还绑定在同一浏览器标签页。因此，sessionStorage 很少被使用。</p>
<h4 id="storage-事件">Storage 事件</h4>
<p>当 localStorage 或 sessionStorage 中的数据更新后，storage 事件就会触发，它具有以下属性：</p>
<ul>
<li>key —— 发生更改的数据的 key（如果调用的是 .clear() 方法，则为 null）。</li>
<li>oldValue —— 旧值（如果是新增数据，则为 null）。</li>
<li>newValue —— 新值（如果是删除数据，则为 null）。</li>
<li>url —— 发生数据更新的文档的 url。</li>
<li>storageArea —— 发生数据更新的 localStorage 或 sessionStorage 对象。</li>
</ul>
<p>重要的是：该事件会在所有可访问到存储对象的 window 对象上触发，导致当前数据改变的 window 对象除外。</p>
<p>我们来详细解释一下。</p>
<p>想象一下，你有两个窗口，它们具有相同的页面。所以 localStorage 在它们之间是共享的。</p>
<p>你可以想在浏览器的两个窗口中打开此页面来测试下面的代码。</p>
<p>如果两个窗口都在监听 window.onstorage 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 在其他文档对同一存储进行更新时触发
</span><span style="color:#75715e"></span>window.<span style="color:#a6e22e">onstorage</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">event</span> =&gt; { <span style="color:#75715e">// 等同于 window.addEventListener(&#39;storage&#39;, () =&gt; {
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;now&#39;</span>) <span style="color:#66d9ef">return</span>;
  <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">newValue</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; at &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">url</span>);
};

<span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#39;now&#39;</span>, Date.<span style="color:#a6e22e">now</span>());
</code></pre></div><p>请注意，该事件还包含：event.url —— 发生数据更新的文档的 url。</p>
<p>并且，event.storageArea 包含存储对象 —— sessionStorage 和 localStorage 具有相同的事件，所以 event.storageArea 引用了被修改的对象。我们可能会想设置一些东西，以“响应”更改。</p>
<p>这允许同源的不同窗口交换消息。</p>
<p>现代浏览器还支持 Broadcast channel API，这是用于同源窗口之间通信的特殊 API，它的功能更全，但被支持的情况不好。有一些库基于 localStorage 来 polyfill 该 API，使其可以用在任何地方。</p>
<h3 id="总结">总结</h3>
<p>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器中保存键/值对。</p>
<ul>
<li>key 和 value 都必须为字符串。</li>
<li>存储大小限制为 5MB+，具体取决于浏览器。</li>
<li>它们不会过期。</li>
<li>数据绑定到源（域/端口/协议）。</li>
</ul>
<p>localStorage	sessionStorage
在同源的所有标签页和窗口之间共享数据	在当前浏览器标签页中可见，包括同源的 iframe
浏览器重启后数据仍然保留	页面刷新后数据仍然保留（但标签页关闭后数据则不再保留）</p>
<h3 id="api">API：</h3>
<ul>
<li>setItem(key, value) —— 存储键/值对。</li>
<li>getItem(key) —— 按照键获取值。</li>
<li>removeItem(key) —— 删除键及其对应的值。</li>
<li>clear() —— 删除所有数据。</li>
<li>key(index) —— 获取该索引下的键名。</li>
<li>length —— 存储的内容的长度。</li>
<li>使用 Object.keys 来获取所有的键。</li>
<li>我们将键作为对象属性来访问，在这种情况下，不会触发 storage 事件。</li>
</ul>
<p>Storage 事件：</p>
<ul>
<li>在调用 setItem，removeItem，clear 方法后触发。</li>
<li>包含有关操作的所有数据（key/oldValue/newValue），文档 url 和存储对象 storageArea。</li>
<li>在所有可访问到存储对象的 window 对象上触发，导致当前数据改变的 window 对象除外（对于 sessionStorage 是在当前标签页下，对于 localStorage 是在全局，即所有同源的窗口）。</li>
</ul>

  </div>
</article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://example.org/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
     - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>olOwOlo</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>

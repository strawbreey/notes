<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Leetcode 1030 Matrix Cells in Distance Order - My New Hugo Site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="olOwOlo" /><meta name="description" content="We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &amp;lt;= r &amp;lt; R and 0 &amp;lt;= c &amp;lt; C.
Additionally, we are given a cell in that matrix with coordinates (r0, c0).
Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance. Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| &#43; |c1 - c2|." />






<meta name="generator" content="Hugo 0.86.0-DEV with theme even" />


<link rel="canonical" href="https://example.org/posts/leetcode/leetcode-1030-matrix-cells-in-distance-order/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">



<meta property="og:title" content="Leetcode 1030 Matrix Cells in Distance Order" />
<meta property="og:description" content="We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.
Additionally, we are given a cell in that matrix with coordinates (r0, c0).
Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance. Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| &#43; |c1 - c2|." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.org/posts/leetcode/leetcode-1030-matrix-cells-in-distance-order/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-17T09:56:46+08:00" />
<meta property="article:modified_time" content="2020-11-17T09:56:46+08:00" />

<meta itemprop="name" content="Leetcode 1030 Matrix Cells in Distance Order">
<meta itemprop="description" content="We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.
Additionally, we are given a cell in that matrix with coordinates (r0, c0).
Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance. Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| &#43; |c1 - c2|."><meta itemprop="datePublished" content="2020-11-17T09:56:46+08:00" />
<meta itemprop="dateModified" content="2020-11-17T09:56:46+08:00" />
<meta itemprop="wordCount" content="341">
<meta itemprop="keywords" content="leetcode," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode 1030 Matrix Cells in Distance Order"/>
<meta name="twitter:description" content="We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.
Additionally, we are given a cell in that matrix with coordinates (r0, c0).
Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance. Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| &#43; |c1 - c2|."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">My New Hugo Site</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">My New Hugo Site</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <p>We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.</p>
<p>Additionally, we are given a cell in that matrix with coordinates (r0, c0).</p>
<p>Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.  Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|.  (You may return the answer in any order that satisfies this condition.</p>
<p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。</p>
<p>另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</p>
<p>返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）</p>
<p>Example:</p>
<pre><code>Input: R = 1, C = 2, r0 = 0, c0 = 0
Output: [[0,0],[0,1]]
Explanation: The distances from (r0, c0) to other cells are: [0,1]

Input: R = 2, C = 2, r0 = 0, c0 = 1
Output: [[0,1],[0,0],[1,1],[1,0]]
Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]
The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.
Example 3:

Input: R = 2, C = 3, r0 = 1, c0 = 2
Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]
There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].
</code></pre><p>Note:</p>
<pre><code>1 &lt;= R &lt;= 100
1 &lt;= C &lt;= 100
0 &lt;= r0 &lt; R
0 &lt;= c0 &lt; C
</code></pre><p>Solution:</p>
<p>方法一：直接排序</p>
<p>最容易想到的方法是首先存储矩阵内所有的点，然后将其按照哈曼顿距离直接排序。</p>
<p>复杂度分析</p>
<ul>
<li>
<p>时间复杂度：O(RC \log(RC))O(RClog(RC))，存储所有点时间复杂度 O(RC)O(RC)，排序时间复杂度 O(RC \log(RC))O(RClog(RC))。</p>
</li>
<li>
<p>空间复杂度：O(\log(RC))O(log(RC))，即为排序需要使用的栈空间，不考虑返回值的空间占用。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">allCellsDistOrder</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">R</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">r0</span>, <span style="color:#a6e22e">c0</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">r</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">R</span>; <span style="color:#a6e22e">r</span><span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">for</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">C</span>; <span style="color:#a6e22e">c</span><span style="color:#f92672">++</span>) {
        <span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">push</span>([<span style="color:#a6e22e">r</span>,<span style="color:#a6e22e">c</span>])
      }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">sort</span>((<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) =&gt; Math.<span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">r0</span>) <span style="color:#f92672">+</span>  Math.<span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">c0</span>)  <span style="color:#f92672">-</span> Math.<span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">r0</span>) <span style="color:#f92672">-</span>  Math.<span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">c0</span>))
};
</code></pre></div><p>方法二：桶排序</p>
<p>注意到方法一中排序的时间复杂度太高。实际在枚举所有点时，我们可以直接按照哈曼顿距离分桶。这样我们就可以实现线性的桶排序。</p>
<p>时间复杂度：O(RC)O(RC)，存储所有点时间复杂度 O(RC)O(RC)，桶排序时间复杂度 O(RC)O(RC)。</p>
<p>空间复杂度：O(RC)O(RC)，需要存储矩阵内所有点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"></code></pre></div><p>方法三：几何法</p>
<p>我们也可以直接变换枚举矩阵的顺序，直接按照曼哈顿距离遍历该矩形即可。</p>
<p>注意到曼哈顿距离相同的位置恰好构成一个斜着的正方形边框，因此我们可以从小到大枚举曼哈顿距离，并使用循环来直接枚举该距离对应的边框。我们每次从该正方形边框的上顶点出发，依次经过右顶点、下顶点和左顶点，最后回到上顶点。这样即可完成当前层的遍历。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"></code></pre></div><p><img src="/images/matrix-cells-in-distance-order.png" alt="matrix-cells-in-distance-order"></p>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/">距离顺序排列矩阵单元格</a></li>
<li><a href="https://leetcode.com/problems/matrix-cells-in-distance-order//">Matrix Cells in Distance Order</a></li>
</ul>

  </div>
</article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://example.org/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
     - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>olOwOlo</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>

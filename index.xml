<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello Friend</title>
    
    
    
    <link>/</link>
    <description>Recent content on Hello Friend</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Sep 2020 16:46:08 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Netty</title>
      <link>/posts/netty/</link>
      <pubDate>Tue, 15 Sep 2020 10:29:58 +0800</pubDate>
      
      <guid>/posts/netty/</guid>
      <description>
        
          
          
          
        
        
        
          Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp;amp; clients.
Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。
todo: References  netty/netty netty developer guide netty.io  Wrods rapidperformancemaintainableasynchronousevent-drivens
          
        
        </description>
    </item>
    
    <item>
      <title>Remote Procedure Call</title>
      <link>/posts/remote-procedure-call/</link>
      <pubDate>Tue, 15 Sep 2020 09:40:57 +0800</pubDate>
      
      <guid>/posts/remote-procedure-call/</guid>
      <description>
        
          
          
          
        
        
        
          在分布式计算(distributed computing)，远程请求（英語：Remote Procedure Call，縮寫為 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。
如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作遠端呼叫或遠端方法呼叫，例：Java RMI。
RPC是一种进程间通信的模式，程序分布在不同的地址空间里。如果在同一主机里，RPC可以通过不同的虚拟地址空间（即便使用相同的物理地址）进行通讯，而在不同的主机间，则通过不同的物理地址进行交互。许多技术（常常是不兼容）都是基于这种概念而实现的。
References Words distributed Procedureexecute 执行
          
        
        </description>
    </item>
    
    <item>
      <title>Showcase</title>
      <link>/showcase/</link>
      <pubDate>Mon, 14 Sep 2020 16:46:08 +0800</pubDate>
      
      <guid>/showcase/</guid>
      <description>
        
          
          
          
        
        
        
          
          
        
        </description>
    </item>
    
    <item>
      <title>Angular Directive</title>
      <link>/posts/angular-directive/</link>
      <pubDate>Mon, 14 Sep 2020 16:31:10 +0800</pubDate>
      
      <guid>/posts/angular-directive/</guid>
      <description>
        
          
          
          
        
        
        
          Angular Directive
          
        
        </description>
    </item>
    
    <item>
      <title>Reactive Forms</title>
      <link>/posts/reactive-forms/</link>
      <pubDate>Mon, 14 Sep 2020 15:33:34 +0800</pubDate>
      
      <guid>/posts/reactive-forms/</guid>
      <description>
        
          
          
          
        
        
        
          响应式表单提供了一种模型驱动的方式来处理表单输入，其中的值会随时间而变化。
响应式表单和模板驱动表单的区别 响应式表单和模板驱动表单以不同的方式处理和管理表单数据。每种方法都有各自的优点。
响应式表单提供对底层表单对象模型直接、显式的访问。它们与模板驱动表单相比，更加健壮：它们的可扩展性、可复用性和可测试性都更高。如果表单是你的应用程序的关键部分，或者你已经在使用响应式表单来构建应用，那就使用响应式表单。
模板驱动表单依赖模板中的指令来创建和操作底层的对象模型。它们对于向应用添加一个简单的表单非常有用，比如电子邮件列表注册表单。它们很容易添加到应用中，但在扩展性方面不如响应式表单。如果你有可以只在模板中管理的非常基本的表单需求和逻辑，那么模板驱动表单就很合适。
   Tables 响应式 模板驱动     建立表单模型 显式的，在组件类中创建 隐式的，由指令创建   数据模型 结构化和不可变的 非结构化和可变的   可预测性 同步 异步   表单验证 函数 指令    响应式表单比模板驱动表单更有可伸缩性。它们提供对底层表单 API 的直接访问，以及对表单数据模型的同步访问，从而可以更轻松地创建大型表单。响应式表单需要较少的测试设置，测试时不需要深入理解变更检测，就能正确测试表单更新和验证。
模板驱动表单专注于简单的场景，可复用性没那么高。它们抽象出了底层表单 API，并且只提供对表单数据模型的异步访问。对模板驱动表单的这种抽象也会影响测试。测试程序非常依赖于手动触发变更检测才能正常运行，并且需要进行更多设置工作。
常用表单基础类 响应式表单和模板驱动表单都建立在下列基础类之上。
 FormControl 实例用于追踪单个表单控件的值和验证状态 FormGroup 用于追踪一个表单控件组的值和状态 FormArray 用于追踪表单控件数组的值和状态 ControlValueAccessor 用于在 Angular 的 FormControl 实例和原生 DOM 元素之间创建一个桥梁。  interface ControlValueAccessor {writeValue(obj: any): void // Writes a new value to the element.
          
        
        </description>
    </item>
    
    <item>
      <title>Elasticsearch</title>
      <link>/posts/elasticsearch/</link>
      <pubDate>Mon, 14 Sep 2020 10:09:20 +0800</pubDate>
      
      <guid>/posts/elasticsearch/</guid>
      <description>
        
          
          
          
        
        
        
          全文搜索属于最常见的需求，开源的 Elasticsearch （以下简称 Elastic）是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它
Elastic 的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。
全文搜索引擎(elasticsearch) install # 下载,解压wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zipunzip elasticsearch-5.5.1.zipcd elasticsearch-5.5.1/ # 启动./bin/elasticsearch注: Elastic 需要 Java 8 环境。默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的config/elasticsearch.yml文件，去掉network.host的注释，将它的值改成0.0.0.0，然后重新启动Elastic。
introduction Node 与 Cluster Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个Elastic 实例。 单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。
Index Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。
所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。
curl -X GET &amp;#39;http://localhost:9200/_cat/indices?v&amp;#39;Document Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。
// document demo{&amp;#34;user&amp;#34;: &amp;#34;张三&amp;#34;,&amp;#34;title&amp;#34;: &amp;#34;工程师&amp;#34;,&amp;#34;desc&amp;#34;: &amp;#34;数据库管理&amp;#34;}同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。
          
        
        </description>
    </item>
    
    <item>
      <title>Redis Cache</title>
      <link>/posts/redis-cache/</link>
      <pubDate>Mon, 14 Sep 2020 10:00:18 +0800</pubDate>
      
      <guid>/posts/redis-cache/</guid>
      <description>
        
          
          
          
        
        
        
          todo:   redis cache
  缓存穿透
  缓存雪崩
  《Redis 设计与实现》
  
          
        
        </description>
    </item>
    
    <item>
      <title>Js Array Index</title>
      <link>/posts/js-array-index/</link>
      <pubDate>Fri, 11 Sep 2020 19:54:40 +0800</pubDate>
      
      <guid>/posts/js-array-index/</guid>
      <description>
        
          
          
          
        
        
        
          JS 中数组字符串索引和数值索引研究 Javascript的数组其实不像PHP或者其他一些语言一样拥有真正的字符串下标，当我们试图为一个js数组添加字符串下标的时候，其实就相当于为该数组对象添加了一个属性，属性名称就是我们所谓的“字符串下标”。由于为数组对象添加属性不会影响到同为该对象属性的length的值，因此该值将始终为零。同样地，.pop()和.shift()等作用于数组元素的方法也不能够作用于这些对象属性。因此，如果要使用的是一个完全由“字符串下标”组成的数组，那还是将其声明为一个Object类型的对象要更好一些。
          
        
        </description>
    </item>
    
    <item>
      <title>Test</title>
      <link>/posts/test/</link>
      <pubDate>Fri, 11 Sep 2020 15:51:38 +0800</pubDate>
      
      <guid>/posts/test/</guid>
      <description>
        
          
          
          
        
        
        
          ssss
          
        
        </description>
    </item>
    
    <item>
      <title>Sql</title>
      <link>/posts/sql/</link>
      <pubDate>Thu, 10 Sep 2020 16:47:25 +0800</pubDate>
      
      <guid>/posts/sql/</guid>
      <description>
        
          
          
          
        
        
        
          数据库 数据库是一以某种方式存储的数据集合
使用crashcourse
use crashcourse;显示数据库
show DATABASES; // 返回可用数据库的列表显示数据库内表的列表
show TABLES; // 显示当前数据库内的表show status // 显示数据库的状态信息show create databaseshow create table #显示创建特定数据库/表show GRANTS // 显示检索数据(SELECT) SELECT prod_name FROM products; -- 检索一列数据SELECT prod_id, prod_name, prod_price FROM products; -- 检索多列数据SELECT * FROM products; -- 检索所有数据SELECT vend_id FROM products; -- 检索vend—id 列SELECT DISTINCT vend_id FROM products; -- 检索vend_id列, 并只返回不同的值SELECT prod_name FROM products LIMIT 5; -- 检索prod_name, 并只返回5条数据SELECT prod_name FROM products LIMIT 5, 5; -- 检索prod_name, 并只返回5条数据SELECT product.
          
        
        </description>
    </item>
    
    <item>
      <title>Linux Install Mysql</title>
      <link>/posts/linux-install-mysql/</link>
      <pubDate>Thu, 10 Sep 2020 10:38:04 +0800</pubDate>
      
      <guid>/posts/linux-install-mysql/</guid>
      <description>
        
          
          
          
        
        
        
          
          
        
        </description>
    </item>
    
    <item>
      <title>Dont Need Lodash</title>
      <link>/posts/dont-need-lodash/</link>
      <pubDate>Wed, 09 Sep 2020 10:26:37 +0800</pubDate>
      
      <guid>/posts/dont-need-lodash/</guid>
      <description>
        
          
          
          
        
        
        
          Lodash and Underscore are great modern JavaScript utility libraries, and they are widely used by Front-end developers. However, when you are targeting modern browsers, you may find out that there are many methods which are already supported natively thanks to ECMAScript5 [ES5] and ECMAScript2015 [ES6]. If you want your project to require fewer dependencies, and you know your target browser clearly, then you may not need Lodash/Underscore.
Quick Links Array
          
        
        </description>
    </item>
    
    <item>
      <title>Scope and Closures</title>
      <link>/posts/scope-and-closures/</link>
      <pubDate>Tue, 08 Sep 2020 19:52:11 +0800</pubDate>
      
      <guid>/posts/scope-and-closures/</guid>
      <description>
        
          
          
          
        
        
        
          reference [ˈrefrəns]n. 说到(或写到)的事;提到;谈及;涉及;参考;查询;查阅;(帮助或意见的)征求，征询v. 查阅;参考;给(书等)附参考资料By contrast 作为对比invokes [ɪnˈvoʊks]v. 援引，援用(法律、规则等作为行动理由);提及，援引(某人、某理论、实例等作为支持);提出(某人的名字，以激发某种感觉或行动)
          
        
        </description>
    </item>
    
    <item>
      <title>Nginx Install</title>
      <link>/posts/nginx-install/</link>
      <pubDate>Tue, 08 Sep 2020 17:32:46 +0800</pubDate>
      
      <guid>/posts/nginx-install/</guid>
      <description>
        
          
          
          
        
        
        
          nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev. For a long time, it has been running on many heavily loaded Russian sites including Yandex, Mail.Ru, VK, and Rambler. According to Netcraft, nginx served or proxied 25.75% busiest sites in August 2020. Here are some of the success stories: Dropbox, Netflix, Wordpress.com, FastMail.FM.
安装Nginx 下载nginx
          
        
        </description>
    </item>
    
    <item>
      <title>Mysql Character</title>
      <link>/posts/mysql-character/</link>
      <pubDate>Tue, 08 Sep 2020 16:08:54 +0800</pubDate>
      
      <guid>/posts/mysql-character/</guid>
      <description>
        
          
          
          
        
        
        
          mysql 字符集选择
对数据库来说，字符集更加重要，因为数据库存储的数据大部分都是各种文字，字符集对数据库的存储，处理性能，以及日后系统的移植，推广都会有影响。 MySQL5.6目前支持几十种字符集，包括UCS-2，UTF-16，UTF-16LE,UTF-32，UTF-8和utf8mb4等Unicode字符集。 根据应用的需求，考虑以下几方面的因素。
 满足应用支持语言的需求，如果应用要处理各种各样的文字，或者将发布到使用不同语言的国家或地区，就应该选择Unicode字符集。对MySQL来说，目前就是UTF-8 如果应用中涉及已有数据的导入，就要充分考虑数据库字符集对已有数据的兼容性。假如已有数据是GBK文字，如果选择GB2312-80为数据库字符集，就很有可能出现某些文字无法正确导入的问题 如果数据库只支持一般中文，数据量很大，性能要求也很高，那就应该选择双字节长编码的中文字符集，比如GBK。因为，相对于UTF-8而言，GBK比较“小”，每个汉字只占2个字节，而UTF-8汉字编码需要3个字节，这样可以减少磁盘I/O，数据库Cache以及网络传输的时间，从而提高性能。相反，如果应用主要处理英文字符，仅有少量汉字数据，那么选择UTF-8更好，因为GBK,UCS-2，UTF-16的西文字符编码都是2个字节，会造成很多不必要的开销。 如果数据库需要做大量的字符运算，如比较，排序等，那么选择定长字符集可能更好，因为定长字符集的处理速度要比变长字符集的处理速度快。 如果所有客户端程序都支持相同的字符集，则应该优先选择该字符集作为数据库字符集，这样可以避免因字符集转换带来的性能开销和数据损失  
          
        
        </description>
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>/posts/dependency-injection/</link>
      <pubDate>Tue, 08 Sep 2020 15:19:09 +0800</pubDate>
      
      <guid>/posts/dependency-injection/</guid>
      <description>
        
          
          
          
        
        
        
          依赖注入
In software engineering, dependency injection is a technique in which an object receives other objects that it depends on. These other objects are called dependencies. In the typical &amp;ldquo;using&amp;rdquo; relationship the receiving object is called a client and the passed (that is, &amp;ldquo;injected&amp;rdquo;) object is called a service. The code that passes the service to the client can be many kinds of things and is called the injector. Instead of the client specifying which service it will use, the injector tells the client what service to use.
          
        
        </description>
    </item>
    
    <item>
      <title>Php Fpm</title>
      <link>/posts/php-fpm/</link>
      <pubDate>Mon, 07 Sep 2020 17:25:15 +0800</pubDate>
      
      <guid>/posts/php-fpm/</guid>
      <description>
        
          
          
          
        
        
        
          PHP-FPM是一个PHP的PHPFastCGI管理器。
PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多优点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。
kill -INT cat /var/run/php-fpm/php-fpm.pid
杀死进程 killall php-fpm
开启进程 /usr/local/php72/sbin/php-fpm
          
        
        </description>
    </item>
    
    <item>
      <title>Js Closure</title>
      <link>/posts/js-closure/</link>
      <pubDate>Mon, 07 Sep 2020 17:02:22 +0800</pubDate>
      
      <guid>/posts/js-closure/</guid>
      <description>
        
          
          
          
        
        
        
          函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。
词法作用域 function init() {var name = &amp;#34;Mozilla&amp;#34;; // name 是一个被 init 创建的局部变量 function displayName() { // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 }displayName();}init();init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数，并且仅在 init() 函数体内可用。请注意，displayName() 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。
闭包 function makeFunc() {var name = &amp;#34;Mozilla&amp;#34;;function displayName() {alert(name);}return displayName;}var myFunc = makeFunc();myFunc();// =&amp;gt; function makeFunc() {var name = &amp;#34;Mozilla&amp;#34;;function displayName() {alert(name);}return displayName;}var myFunc = makeFunc();var myFunc = displayName() {alert(name);}(displayName() {alert(name);})()function makeAdder(x) {return function(y) {return x + y;};}var add5 = makeAdder(5);var add10 = makeAdder(10);console.
          
        
        </description>
    </item>
    
    <item>
      <title>Git Workflow</title>
      <link>/posts/git-workflow/</link>
      <pubDate>Mon, 07 Sep 2020 15:49:49 +0800</pubDate>
      
      <guid>/posts/git-workflow/</guid>
      <description>
        
          
          
          
        
        
        
          Git 作为一个源码管理系统，不可避免涉及到多人协作。
协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。&amp;ldquo;工作流程&amp;quot;在英语里，叫做&amp;quot;workflow&amp;quot;或者&amp;quot;flow&amp;rdquo;，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。
相关文章  《Git 使用规范流程》 《常用 Git 命令清单》 《Git 远程操作详解》  
          
        
        </description>
    </item>
    
    <item>
      <title>Debounce and Throttle</title>
      <link>/posts/debounce-and-throttle/</link>
      <pubDate>Mon, 07 Sep 2020 14:51:32 +0800</pubDate>
      
      <guid>/posts/debounce-and-throttle/</guid>
      <description>
        
          
          
          
        
        
        
          防抖  根据一个选择器函数，舍弃掉在两次输出之间小于指定时间的发出值。
  实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法 缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟  // RxJS v6+import { of, timer } from &amp;#39;rxjs&amp;#39;;import { debounce } from &amp;#39;rxjs/operators&amp;#39;;// 发出四个字符串const example = of(&amp;#39;WAIT&amp;#39;, &amp;#39;ONE&amp;#39;, &amp;#39;SECOND&amp;#39;, &amp;#39;Last will display&amp;#39;);/*只有在最后一次发送后再经过一秒钟，才会发出值，并抛弃在此之前的所有其他值*/const debouncedExample = example.pipe(debounce(() =&amp;gt; timer(1000)));/*在这个示例中，所有的值都将被忽略，除了最后一个输出: &amp;#39;Last will display&amp;#39;*/const subscribe = debouncedExample.subscribe(val =&amp;gt; console.log(val));// lodash 4.17_.debounce(func, [wait=0], [options={}])实现方式: 参考资料  rxjs debounce debounce lodash debounce source code  截流 以某个时间间隔为阈值，在 durationSelector 完成前将抑制新值的发出
          
        
        </description>
    </item>
    
    <item>
      <title>Go Interview</title>
      <link>/posts/go-interview/</link>
      <pubDate>Thu, 03 Sep 2020 16:18:11 +0800</pubDate>
      
      <guid>/posts/go-interview/</guid>
      <description>
        
          
          
          
        
        
        
          func main(){s := []int{5}fmt.Println(len(s), cap(s))s = append(s, 7)fmt.Println(len(s), cap(s))s = append(s, 9)fmt.Println(len(s), cap(s))x := append(s, 11)fmt.Println(len(s), cap(s))y := append(s, 12)fmt.Println(len(s), cap(s))fmt.Println(s, x, y)// 输出结果 [5 7 9] [5 7 9 12] [5 7 9 12]s := []int{5, 7, 9}x := append(s, 11)y := append(s, 12)fmt.Println(s,x,y)// 输出结果 [5 7 9] [5 7 9 11] [5 7 9 12]s := []int{5} // 初始化切片为[5], cap(s) = 1 len (s) = 1 fmt.
          
        
        </description>
    </item>
    
    <item>
      <title>Go Slice</title>
      <link>/posts/go-slice/</link>
      <pubDate>Thu, 03 Sep 2020 15:42:47 +0800</pubDate>
      
      <guid>/posts/go-slice/</guid>
      <description>
        
          
          
          
        
        
        
          go slice Go 语言切片是对数组的抽象。
Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(&amp;ldquo;动态数组&amp;rdquo;),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。
定义切片 var identifier []type切片不需要说明长度。
或使用make()函数来创建切片:
var slice1 []type = make([]type, len)// 也可以简写为slice1 := make([]type, len)也可以指定容量，其中capacity为可选参数。
make([]T, length, capacity)slice init s := [] int {1,2,3 } // 直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3s := arr[:]// 初始化切片s,是数组arr的引用s := arr[startIndex:endIndex] // 将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片s1 := s[startIndex:endIndex] // 通过切片s初始化切片s1s :=make([]int,len,cap) // 通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片len() 和 cap() 切片是可索引的，并且可以由 len() 方法获取长度。
          
        
        </description>
    </item>
    
    <item>
      <title>Go Start</title>
      <link>/posts/go-start/</link>
      <pubDate>Thu, 03 Sep 2020 15:17:10 +0800</pubDate>
      
      <guid>/posts/go-start/</guid>
      <description>
        
          
          
          
        
        
        
          go command ( go 常用命令) Usage:go &amp;lt;command&amp;gt; [arguments]The commands are:bug start a bug reportbuild compile packages and dependenciesclean remove object files and cached filesdoc show documentation for package or symbolenv print Go environment informationfix update packages to use new APIsfmt gofmt (reformat) package sourcesgenerate generate Go files by processing sourceget add dependencies to current module and install theminstall compile and install packages and dependencieslist list packages or modulesmod module maintenancerun compile and run Go programtest test packagestool run specified go toolversion print Go versionvet report likely mistakes in packagesUse &amp;#34;go help &amp;lt;command&amp;gt;&amp;#34; for more information about a command.
          
        
        </description>
    </item>
    
    <item>
      <title>WebAssembly</title>
      <link>/posts/webassembly/</link>
      <pubDate>Thu, 03 Sep 2020 14:57:11 +0800</pubDate>
      
      <guid>/posts/webassembly/</guid>
      <description>
        
          
          
          
        
        
        
          WebAssembly WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.
Efficient and fast Safe Open and debuggable Part of the open web platform Start $ git clone https://github.com/juj/emsdk.git$ cd emsdk$ ./emsdk install sdk-incoming-64bit binaryen-master-64bit$ ./emsdk activate sdk-incoming-64bit binaryen-master-64bit$ source ./emsdk_env.sh如何使用 WebAssembly 整个代码库都用 WebAssembly。主要使用 WebAssembly 计算，UI 使用 JavaScript/HTML。在大型 JavaScript/HTML 应用中复用已经存在的 WebAssembly 代码。像使用助手库一样，分担一些计算任务。
          
        
        </description>
    </item>
    
    <item>
      <title>Angular Service</title>
      <link>/posts/angular-service/</link>
      <pubDate>Thu, 03 Sep 2020 10:49:58 +0800</pubDate>
      
      <guid>/posts/angular-service/</guid>
      <description>
        
          
          
          
        
        
        
          Angular Directive
          
        
        </description>
    </item>
    
    <item>
      <title>Css Interivew Repaint and Refolw</title>
      <link>/posts/css-interivew-repaint-and-refolw/</link>
      <pubDate>Thu, 03 Sep 2020 10:48:27 +0800</pubDate>
      
      <guid>/posts/css-interivew-repaint-and-refolw/</guid>
      <description>
        
          
          
          
        
        
        
          repaint-and-refolw (重绘和回流) 从上面这个图上，我们可以看到，浏览器渲染过程如下：
  解析HTML，生成DOM树，解析CSS，生成CSSOM树
  将DOM树和CSSOM树结合，生成渲染树(Render Tree)
  Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
  Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
  Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）
  回流 (重新计算DOM节点) 前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。
什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。
 注意：渲染树只包含可见的节点
 何时发生回流  添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）   注意：回流一定会触发重绘，而重绘不一定会回流
 重绘 (重新构造渲染树) 我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。
浏览器的优化机制 现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。
 当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect  减少回流和重绘  合并多次对DOM和样式的修改 批量修改DOM  使元素脱离文档流 对其进行多次修改 将元素带回到文档中。
有三种方式可以让DOM脱离文档流：
隐藏元素，应用修改，重新显示 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。
对于复杂动画效果,使用绝对定位让其脱离文档流
比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。
          
        
        </description>
    </item>
    
    <item>
      <title>Css Interview BFC</title>
      <link>/posts/css-interview-bfc/</link>
      <pubDate>Thu, 03 Sep 2020 10:02:39 +0800</pubDate>
      
      <guid>/posts/css-interview-bfc/</guid>
      <description>
        
          
          
          
        
        
        
          Describe BFC (Block Formatting Context) and how it works.
 BFC(Block formatting context) 块级格式化上下文 A block formatting context is a part of a visual CSS rendering of a web page. It&amp;rsquo;s the region in which the layout of block boxes occurs and in which floats interact with other elements.
BFC是Web页面的CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域
what A block formatting context is created by at least one of the following:
 The root element of the document ().
          
        
        </description>
    </item>
    
    <item>
      <title>Mysql Command</title>
      <link>/posts/mysql-command/</link>
      <pubDate>Tue, 01 Sep 2020 16:19:22 +0800</pubDate>
      
      <guid>/posts/mysql-command/</guid>
      <description>
        
          
          
          
        
        
        
          Can&amp;#39;t connect to local MySQL server through socket &amp;#39;/var/lib/mysql/mysql.sock&amp;#39; 导出数据 mysqldump -u root -p ieg_waibao_test &amp;gt; test_db.sql;
登录mysql mysql -u root -p
          
        
        </description>
    </item>
    
    <item>
      <title>Go Types</title>
      <link>/posts/go-types/</link>
      <pubDate>Tue, 01 Sep 2020 11:20:46 +0800</pubDate>
      
      <guid>/posts/go-types/</guid>
      <description>
        
          
          
          
        
        
        
          Go 数据类型  布尔类型 boolean 数字类型 int float32 float64 字符串类型 string 派生类型  
          
        
        </description>
    </item>
    
    <item>
      <title>Linux Install Php</title>
      <link>/posts/linux-install-php/</link>
      <pubDate>Tue, 01 Sep 2020 10:10:41 +0800</pubDate>
      
      <guid>/posts/linux-install-php/</guid>
      <description>
        
          
          
          
        
        
        
          Install PHP install php5.6 wget -c http://cn2.php.net/distributions/php-5.6.21.tar.gztar -zxvf php-5.6.21.tar.gz格式：tar zcvf 压缩后的路径及包名 你要压缩的文件
　z:gzip压缩
　c:创建压缩包
　v:显示打包压缩解压过程
　f:接着压缩
　t:查看压缩包内容
　x:解压
　X:指定文件列表形式排除不需要打包压缩的文件或目录
　-exclude:指定排除文件或目录不需要打包压缩的文件或目录（也可以用正则匹配/通配符等）
　-C:解压到指定目录
例如：将/root/cs/test/下文件压缩到/root/cs/test1文件下命名为1
tar zcf /root/cs/test1/1.tar.gz /root/cs/test/
zcvf : 打包压缩 xvf: 解压缩
php 下载 解压 配置 编译 https://www.php.net/distributions/php-7.2.33.tar.gz
wget http://cn2.php.net/distributions/php-7.2.33.tar.gz tar xf php-7.2.33.tar.xz
tar -zxvf php-7.2.33.tar.xz
./configure &amp;ndash;prefix=/usr/local/php72 &amp;ndash;with-config-file-path=/usr/local/php72/etc &amp;ndash;with-mysql=mysqlnd &amp;ndash;with-mysqli=mysqlnd &amp;ndash;with-pdo-mysql=mysqlnd &amp;ndash;with-gd &amp;ndash;with-iconv &amp;ndash;with-zlib &amp;ndash;enable-xml &amp;ndash;enable-bcmath &amp;ndash;enable-shmop &amp;ndash;enable-sysvsem &amp;ndash;enable-inline-optimization &amp;ndash;enable-mbregex &amp;ndash;enable-fpm &amp;ndash;enable-mbstring &amp;ndash;enable-ftp &amp;ndash;enable-gd-native-ttf &amp;ndash;with-openssl &amp;ndash;enable-pcntl &amp;ndash;enable-sockets &amp;ndash;with-xmlrpc &amp;ndash;enable-zip &amp;ndash;enable-soap &amp;ndash;with-pear &amp;ndash;with-gettext &amp;ndash;enable-session &amp;ndash;with-mcrypt &amp;ndash;with-curl
          
        
        </description>
    </item>
    
    <item>
      <title>Git Common Commands</title>
      <link>/posts/git-common-commands/</link>
      <pubDate>Mon, 31 Aug 2020 15:39:29 +0800</pubDate>
      
      <guid>/posts/git-common-commands/</guid>
      <description>
        
          
          
          
        
        
        
          Git不需要输入用户名密码的两种方式   采用ssh连接方式: 将自己主机的id_ras.pub 加到git 的ssh Keys 中
  采用https的连接方式:
  git config --global credential.helper store
          
        
        </description>
    </item>
    
    <item>
      <title>Git Undo</title>
      <link>/posts/git-undo/</link>
      <pubDate>Mon, 31 Aug 2020 15:11:27 +0800</pubDate>
      
      <guid>/posts/git-undo/</guid>
      <description>
        
          
          
          
        
        
        
          undo #Clone your git repogit clone https://github.com/lestatzhang/lestatzhang.github.io.git;#Entre your local repocd lestatzhang.github.io;#Checkoutgit checkout --orphan latest_branch;#Add all the filesgit add -A;#Commit the changesgit commit -am &amp;#34;Reinitialize&amp;#34;;#Delete the branchgit branch -D master;#Rename the current branch to mastergit branch -m master;#Finally, force update your repositorygit push -f origin master;  git reset --hard HEAD^ git push --force
          
        
        </description>
    </item>
    
    <item>
      <title>Linux Permissions</title>
      <link>/posts/linux-permissions/</link>
      <pubDate>Mon, 31 Aug 2020 11:17:11 +0800</pubDate>
      
      <guid>/posts/linux-permissions/</guid>
      <description>
        
          
          
          
        
        
        
          look auth r = 读取权限 (4) w = 写入权限 (2) x = 执行权限 (1)
1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。
444 r&amp;ndash;r&amp;ndash;r&amp;ndash; 600 rw&amp;mdash;&amp;mdash;- 644 rw-r&amp;ndash;r&amp;ndash; 666 rw-rw-rw- 700 rwx&amp;mdash;&amp;mdash; 744 rwxr&amp;ndash;r&amp;ndash; 755 rwxr-xr-x 777 rwxrwxrwx
Quote   Linux修改目录权限
  How do I change permissions for a folder and all of its subfolders and files in one step in Linux?
  chmod command
  
          
        
        </description>
    </item>
    
    <item>
      <title>Common Commands</title>
      <link>/posts/common-commands/</link>
      <pubDate>Mon, 31 Aug 2020 10:36:43 +0800</pubDate>
      
      <guid>/posts/common-commands/</guid>
      <description>
        
          
          
          
        
        
        
          # 测试镜像是否有用nslookup mirrors.tencent.comrpm -Uvh https://mirrors.tencent.com/tlinux/rpm/tlinux-release-2-11.tl2.x86_64.rpm# 下载phpwget php-7.2.15.tar.bz2 http://cn2.php.net/distributions/php-7.2.15.tar.bz2yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpmrpm -Uvh https://mirrors.tencent.com/tlinux/rpm/epel-release-6-12.tl1.noarch.rpm# linux cp 复制sudo cp /opt/soft/php/sbin/php-fpm /usr/local/bin/ sudo php-fpm# linux 杀死进程 kill -INT cat /usr/local/php/var/run/php-fpm.pid# linux 安装yum -y install gcc openssl openssl-devel curl curl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel pcre pcre-devel libxslt libxslt-devel bzip2 bzip2-devel# linux 杀死全部进程killall php-fpm# linux 查询进程 phpps -ef|grep php# linux 重载nginx -s reload链接数据库异常
          
        
        </description>
    </item>
    
    <item>
      <title>Host on Github</title>
      <link>/posts/host-on-github/</link>
      <pubDate>Mon, 31 Aug 2020 10:32:49 +0800</pubDate>
      
      <guid>/posts/host-on-github/</guid>
      <description>
        
          
          
          
        
        
        
          Assumptions  Git 2.8 Github Account  
          
        
        </description>
    </item>
    
    <item>
      <title>Git Submodule</title>
      <link>/git-submodule/</link>
      <pubDate>Mon, 31 Aug 2020 10:20:39 +0800</pubDate>
      
      <guid>/git-submodule/</guid>
      <description>
        
          
          
          
        
        
        
          
          
        
        </description>
    </item>
    
    <item>
      <title>Hugo Start</title>
      <link>/posts/hugo-start/</link>
      <pubDate>Mon, 31 Aug 2020 10:15:27 +0800</pubDate>
      
      <guid>/posts/hugo-start/</guid>
      <description>
        
          
          
          
        
        
        
          start Install Hugo # macOS install brew intall hugohugo versionCreate a New Site hugo new site quickStartAdd a Theme cd quickstartgit initgit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/anankeAdd Some Content hugo new posts/new-content.mdStart the Hugo server hugo serve -DBuild Static pages hugo -D
          
        
        </description>
    </item>
    
    <item>
      <title>Git</title>
      <link>/posts/git/</link>
      <pubDate>Fri, 28 Aug 2020 19:29:52 +0800</pubDate>
      
      <guid>/posts/git/</guid>
      <description>
        
          
          
          
        
        
        
          create a new repository on the command line git initgit add README.mdgit commit -m &amp;quot;first commit&amp;quot;git branch -M mastergit remote add origin https://github.com/strawbreey/notes.gitgit push -u origin masterpush an existing repository from the command line git remote add origin https://github.com/strawbreey/notes.gitgit branch -M mastergit push -u origin mastercreate gh-pages branch git checkout --orphan gh-pagesgit reset --hardgit commit --allow-empty -m &amp;#34;Initializing gh-pages branch&amp;#34;git push upstream gh-pagesgit checkout mastergit remote add origin https://github.
          
        
        </description>
    </item>
    
    <item>
      <title>Interview</title>
      <link>/posts/interview/</link>
      <pubDate>Fri, 28 Aug 2020 19:20:30 +0800</pubDate>
      
      <guid>/posts/interview/</guid>
      <description>
        
          
          
          
        
        
        
          
          
        
        </description>
    </item>
    
    <item>
      <title>Hugo</title>
      <link>/hugo/</link>
      <pubDate>Fri, 28 Aug 2020 19:18:18 +0800</pubDate>
      
      <guid>/hugo/</guid>
      <description>
        
          
          
          
        
        
        
          创建文章 创建一个hugo页面
hugo new hugo.md内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 &amp;mdash; 标记）或者 JSON 格式。
安装皮肤 cd themesgit clone https://github.com/spf13/hyde.git运行hugo hugo server --theme=hyde --buildDrafts
          
        
        </description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Fri, 28 Aug 2020 19:17:20 +0800</pubDate>
      
      <guid>/about/</guid>
      <description>
        
          
          
          
        
        
        
          创建文章 创建一个hugo页面
hugo new hugo.md内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 &amp;mdash; 标记）或者 JSON 格式。
安装皮肤 cd themesgit clone https://github.com/spf13/hyde.git运行hugo hugo server --theme=hyde --buildDrafts
          
        
        </description>
    </item>
    
  </channel>
</rss>
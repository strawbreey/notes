<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Strawbreey Notes</title>
    
    
    
    <link>/tags/leetcode/</link>
    <description>Recent content in leetcode on Strawbreey Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright©2019-2020 Strawbreey. All Rights Reserved</copyright>
    <lastBuildDate>Thu, 26 Nov 2020 10:59:04 +0800</lastBuildDate>
    
	<atom:link href="/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 1370 Increasing Decreasing String</title>
      <link>/posts/leetcode-1370-increasing-decreasing-string/</link>
      <pubDate>Thu, 26 Nov 2020 10:59:04 +0800</pubDate>
      
      <guid>/posts/leetcode-1370-increasing-decreasing-string/</guid>
      <description>
        
          
          
          
        
        
        
          给你一个字符串 s ，请你根据下面的算法重新构造字符串：
  从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
  从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
  重复步骤 2 ，直到你没法从 s 中选择字符。
  从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
  从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
  重复步骤 5 ，直到你没法从 s 中选择字符。
  重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。
  在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。
  请你返回将 s 中字符重新排序后的 结果字符串 。
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0222 Count Complete Tree Nodes</title>
      <link>/posts/leetcode-0222-count-complete-tree-nodes/</link>
      <pubDate>Tue, 24 Nov 2020 23:35:16 +0800</pubDate>
      
      <guid>/posts/leetcode-0222-count-complete-tree-nodes/</guid>
      <description>
        
          
          
          
        
        
        
          给出一个完全二叉树，求出该树的节点个数。
说明：
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
示例:
输入: 1 /
2 3 / \ / 4 5 6
输出: 6
/*** Definition for a binary tree node.* function TreeNode(val) {* this.val = val;* this.left = this.right = null;* }*//*** @param {TreeNode} root* @return {number}*/var countNodes = function(root) {if (root == null) {return 0}return countNodes(root.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0020 Valid Parentheses</title>
      <link>/posts/leetcode-0020-valid-parentheses/</link>
      <pubDate>Tue, 24 Nov 2020 23:28:48 +0800</pubDate>
      
      <guid>/posts/leetcode-0020-valid-parentheses/</guid>
      <description>
        
          
          
          
        
        
        
          给定一个只包括 &amp;lsquo;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&amp;rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。
输入: &amp;quot;()&amp;quot;输出: true输入: &amp;quot;()[]{}&amp;quot;输出: true输入: &amp;quot;(]&amp;quot;输出: false输入: &amp;quot;([)]&amp;quot;输出: falsesolution:
/*** @param {string} s* @return {boolean}*/var isValid = function(s) {let arr = []let count = 0let obj = {&amp;#39;(&amp;#39;: &amp;#39;)&amp;#39;,&amp;#39;{&amp;#39;: &amp;#39;}&amp;#39;,&amp;#39;[&amp;#39;: &amp;#39;]&amp;#39;}while (s) {if (s[0] == &amp;#39;(&amp;#39; || s[0] == &amp;#39;{&amp;#39; || s[0] == &amp;#39;[&amp;#39;) {arr.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0009 Palidrome Number</title>
      <link>/posts/leetcode-0009-palidrome-number/</link>
      <pubDate>Tue, 24 Nov 2020 22:29:15 +0800</pubDate>
      
      <guid>/posts/leetcode-0009-palidrome-number/</guid>
      <description>
        
          
          
          
        
        
        
          判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。输入: 121输出: true输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。// 方案一/*** @param {number} x* @return {boolean}*/var isPalindrome = function(x) {if (x &amp;lt; 0) {return false}let num = xlet t = 0while (num) {t = t * 10 + num % 10 num = Math.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 1014 Best Sightseeing Pair</title>
      <link>/posts/leetcode-1014-best-sightseeing-pair/</link>
      <pubDate>Mon, 23 Nov 2020 22:54:56 +0800</pubDate>
      
      <guid>/posts/leetcode-1014-best-sightseeing-pair/</guid>
      <description>
        
          
          
          
        
        
        
          给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。
一对景点（i &amp;lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。
返回一对观光景点能取得的最高分。
输入：[8,1,5,2,6]输出：11解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11提示:
2 &amp;lt;= A.length &amp;lt;= 500001 &amp;lt;= A[i] &amp;lt;= 1000/*** @param {number[]} A* @return {number}*/var maxScoreSightseeingPair = function(A) {let count = A[0] + A[1] - 1 for (let i = 0; i&amp;lt;A.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0452 Mininum Number of Arrows to Burst Balloons</title>
      <link>/posts/leetcode-0452-mininum-number-of-arrows-to-burst-balloons/</link>
      <pubDate>Mon, 23 Nov 2020 19:36:30 +0800</pubDate>
      
      <guid>/posts/leetcode-0452-mininum-number-of-arrows-to-burst-balloons/</guid>
      <description>
        
          
          
          
        
        
        
          在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2输入：points = [[1,2]]输出：1输入：points = [[2,3],[2,3]]输出：1提示：
 0 &amp;lt;= points.length &amp;lt;= 104points[i].length == 2-231 &amp;lt;= xstart &amp;lt; xend &amp;lt;= 231 - 1Solution
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0056 Merge Intervals</title>
      <link>/posts/leetcode-0056-merge-intervals/</link>
      <pubDate>Mon, 23 Nov 2020 00:26:57 +0800</pubDate>
      
      <guid>/posts/leetcode-0056-merge-intervals/</guid>
      <description>
        
          
          
          
        
        
        
          给出一个区间的集合，请合并所有重叠的区间。
示例 1:
输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:
输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。
 提示：
intervals[i][0] &amp;lt;= intervals[i][1]
/*** @param {number[][]} intervals* @return {number[][]}*/var merge = function(intervals) {points = intervals.sort((a,b) =&amp;gt; (a[0] - b[0]) || (a[1] - b[1]))let mergeArr = [], count = 0;for (let i = 0; i&amp;lt; points.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0242 Valid Anagram</title>
      <link>/posts/leetcode-0242-valid-anagram/</link>
      <pubDate>Sun, 22 Nov 2020 22:38:27 +0800</pubDate>
      
      <guid>/posts/leetcode-0242-valid-anagram/</guid>
      <description>
        
          
          
          
        
        
        
          Given two strings s and t , write a function to determine if t is an anagram of s.
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
Example:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;Output: trueInput: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;Output: falseNote:
You may assume the string contains only lowercase alphabets. 你可以假设字符串只包含小写字母。
Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0147 Insertion Sort List</title>
      <link>/posts/leetcode-0147-insertion-sort-list/</link>
      <pubDate>Fri, 20 Nov 2020 09:45:27 +0800</pubDate>
      
      <guid>/posts/leetcode-0147-insertion-sort-list/</guid>
      <description>
        
          
          
          
        
        
        
          Sort a linked list using insertion sort.
A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list
Algorithm of Insertion Sort:
 Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0283 Move Zeros</title>
      <link>/posts/leetcode-0283-move-zeros/</link>
      <pubDate>Thu, 19 Nov 2020 10:00:00 +0800</pubDate>
      
      <guid>/posts/leetcode-0283-move-zeros/</guid>
      <description>
        
          
          
          
        
        
        
          Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
Example:
Input: [0,1,0,3,12]Output: [1,3,12,0,0]Note:
You must do this in-place without making a copy of the array. Minimize the total number of operations.
说明:
必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。
Solution
非零元素右移， 然后补零
/*** @param {number[]} nums* @return {void} Do not return anything, modify nums in-place instead.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0134 Gas Station</title>
      <link>/posts/leetcode-0134-gas-station/</link>
      <pubDate>Wed, 18 Nov 2020 10:05:57 +0800</pubDate>
      
      <guid>/posts/leetcode-0134-gas-station/</guid>
      <description>
        
          
          
          
        
        
        
          There are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station&amp;rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 1030 Matrix Cells in Distance Order</title>
      <link>/posts/leetcode-1030-matrix-cells-in-distance-order/</link>
      <pubDate>Tue, 17 Nov 2020 09:56:46 +0800</pubDate>
      
      <guid>/posts/leetcode-1030-matrix-cells-in-distance-order/</guid>
      <description>
        
          
          
          
        
        
        
          We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &amp;lt;= r &amp;lt; R and 0 &amp;lt;= c &amp;lt; C.
Additionally, we are given a cell in that matrix with coordinates (r0, c0).
Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance. Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|.
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0007 Reverse Integer</title>
      <link>/posts/leetcode-0007-reverse-integer/</link>
      <pubDate>Fri, 06 Nov 2020 19:54:54 +0800</pubDate>
      
      <guid>/posts/leetcode-0007-reverse-integer/</guid>
      <description>
        
          
          
          
        
        
        
          Given a 32-bit signed integer, reverse digits of an integer.
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
Example:
Input: x = 123Output: 321Input: x = -123Output: -321Input: x = 120Output: 21Input: x = 0Output: 0/*** @param {number} x* @return {number}*/var reverse = function(x) {let num = 0let flag = x &amp;gt; 0 ?
          
        
        </description>
    </item>
    
    <item>
      <title>Leetcode 0001 Two Sum</title>
      <link>/posts/leetcode-0001-two-sum/</link>
      <pubDate>Fri, 06 Nov 2020 17:03:36 +0800</pubDate>
      
      <guid>/posts/leetcode-0001-two-sum/</guid>
      <description>
        
          
          
          
        
        
        
          Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
Example: Input: nums = [2,7,11,15], target = 9Output: [0,1] Because nums[0] + nums[1] == 9, we return [0, 1].
          
        
        </description>
    </item>
    
  </channel>
</rss>